// This file was autogenerated by some hot garbage in the `uniffi-bindgen-react-native` crate.
// Trust me, you don't want to mess with it!
import nativeModule, {
  type UniffiRustFutureContinuationCallback,
  type UniffiForeignFuture,
  type UniffiForeignFutureStructU8,
  type UniffiForeignFutureCompleteU8,
  type UniffiForeignFutureStructI8,
  type UniffiForeignFutureCompleteI8,
  type UniffiForeignFutureStructU16,
  type UniffiForeignFutureCompleteU16,
  type UniffiForeignFutureStructI16,
  type UniffiForeignFutureCompleteI16,
  type UniffiForeignFutureStructU32,
  type UniffiForeignFutureCompleteU32,
  type UniffiForeignFutureStructI32,
  type UniffiForeignFutureCompleteI32,
  type UniffiForeignFutureStructU64,
  type UniffiForeignFutureCompleteU64,
  type UniffiForeignFutureStructI64,
  type UniffiForeignFutureCompleteI64,
  type UniffiForeignFutureStructF32,
  type UniffiForeignFutureCompleteF32,
  type UniffiForeignFutureStructF64,
  type UniffiForeignFutureCompleteF64,
  type UniffiForeignFutureStructPointer,
  type UniffiForeignFutureCompletePointer,
  type UniffiForeignFutureStructRustBuffer,
  type UniffiForeignFutureCompleteRustBuffer,
  type UniffiForeignFutureStructVoid,
  type UniffiForeignFutureCompleteVoid,
} from './vella_sdk-ffi';
import {
  type FfiConverter,
  type UniffiByteArray,
  type UniffiObjectFactory,
  type UniffiRustArcPtr,
  type UnsafeMutableRawPointer,
  AbstractFfiConverterByteArray,
  FfiConverterArray,
  FfiConverterBool,
  FfiConverterInt32,
  FfiConverterInt64,
  FfiConverterMap,
  FfiConverterObject,
  FfiConverterOptional,
  FfiConverterUInt32,
  FfiConverterUInt64,
  RustBuffer,
  UniffiAbstractObject,
  UniffiEnum,
  UniffiError,
  UniffiInternalError,
  UniffiRustCaller,
  destructorGuardSymbol,
  pointerLiteralSymbol,
  uniffiCreateFfiConverterString,
  uniffiCreateRecord,
  uniffiTypeNameSymbol,
  variantOrdinalSymbol,
} from 'uniffi-bindgen-react-native';

// Get converters from the other files, if any.
const uniffiCaller = new UniffiRustCaller();

const uniffiIsDebug =
  // @ts-ignore -- The process global might not be defined
  typeof process !== 'object' ||
  // @ts-ignore -- The process global might not be defined
  process?.env?.NODE_ENV !== 'production' ||
  false;
// Public interface members begin here.

export function escapeText(text: string): string {
  return FfiConverterString.lift(
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_vella_sdk_fn_func_escape_text(
          FfiConverterString.lower(text),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    )
  );
}
export function parseBatchResponse(body: string): Array<BatchSection> {
  return FfiConverterArrayTypeBatchSection.lift(
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_vella_sdk_fn_func_parse_batch_response(
          FfiConverterString.lower(body),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    )
  );
}
export function parseEmail(raw: string): Email /*throws*/ {
  return FfiConverterTypeEmail.lift(
    uniffiCaller.rustCallWithError(
      /*liftError:*/ FfiConverterTypeParserError.lift.bind(
        FfiConverterTypeParserError
      ),
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_vella_sdk_fn_func_parse_email(
          FfiConverterString.lower(raw),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    )
  );
}
export function parseVisibleHtml(body: string): string | undefined {
  return FfiConverterOptionalString.lift(
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_vella_sdk_fn_func_parse_visible_html(
          FfiConverterString.lower(body),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    )
  );
}
export function parseVisibleText(body: string): string | undefined {
  return FfiConverterOptionalString.lift(
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_vella_sdk_fn_func_parse_visible_text(
          FfiConverterString.lower(body),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    )
  );
}

export type BatchSection = {
  batchName: string;
  response: BatchResponse;
};

/**
 * Generated factory for {@link BatchSection} record objects.
 */
export const BatchSection = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<BatchSection, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link BatchSection}, with defaults specified
     * in Rust, in the {@link vella_sdk} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link BatchSection}, with defaults specified
     * in Rust, in the {@link vella_sdk} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link vella_sdk} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<BatchSection>,
  });
})();

const FfiConverterTypeBatchSection = (() => {
  type TypeName = BatchSection;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        batchName: FfiConverterString.read(from),
        response: FfiConverterTypeBatchResponse.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.batchName, into);
      FfiConverterTypeBatchResponse.write(value.response, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.batchName) +
        FfiConverterTypeBatchResponse.allocationSize(value.response)
      );
    }
  }
  return new FFIConverter();
})();

export type CalendarEvent = {
  uid: string | undefined;
  summary: string | undefined;
  status: CalendarEventStatus | undefined;
  url: string | undefined;
  googleConferenceLink: string | undefined;
  location: string | undefined;
  timestamp: /*i64*/ bigint | undefined;
  lastModified: /*i64*/ bigint | undefined;
  created: /*i64*/ bigint | undefined;
  start: /*i64*/ bigint | undefined;
  end: /*i64*/ bigint | undefined;
};

/**
 * Generated factory for {@link CalendarEvent} record objects.
 */
export const CalendarEvent = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<CalendarEvent, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link CalendarEvent}, with defaults specified
     * in Rust, in the {@link vella_sdk} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link CalendarEvent}, with defaults specified
     * in Rust, in the {@link vella_sdk} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link vella_sdk} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<CalendarEvent>,
  });
})();

const FfiConverterTypeCalendarEvent = (() => {
  type TypeName = CalendarEvent;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        uid: FfiConverterOptionalString.read(from),
        summary: FfiConverterOptionalString.read(from),
        status: FfiConverterOptionalTypeCalendarEventStatus.read(from),
        url: FfiConverterOptionalString.read(from),
        googleConferenceLink: FfiConverterOptionalString.read(from),
        location: FfiConverterOptionalString.read(from),
        timestamp: FfiConverterOptionalInt64.read(from),
        lastModified: FfiConverterOptionalInt64.read(from),
        created: FfiConverterOptionalInt64.read(from),
        start: FfiConverterOptionalInt64.read(from),
        end: FfiConverterOptionalInt64.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterOptionalString.write(value.uid, into);
      FfiConverterOptionalString.write(value.summary, into);
      FfiConverterOptionalTypeCalendarEventStatus.write(value.status, into);
      FfiConverterOptionalString.write(value.url, into);
      FfiConverterOptionalString.write(value.googleConferenceLink, into);
      FfiConverterOptionalString.write(value.location, into);
      FfiConverterOptionalInt64.write(value.timestamp, into);
      FfiConverterOptionalInt64.write(value.lastModified, into);
      FfiConverterOptionalInt64.write(value.created, into);
      FfiConverterOptionalInt64.write(value.start, into);
      FfiConverterOptionalInt64.write(value.end, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterOptionalString.allocationSize(value.uid) +
        FfiConverterOptionalString.allocationSize(value.summary) +
        FfiConverterOptionalTypeCalendarEventStatus.allocationSize(
          value.status
        ) +
        FfiConverterOptionalString.allocationSize(value.url) +
        FfiConverterOptionalString.allocationSize(value.googleConferenceLink) +
        FfiConverterOptionalString.allocationSize(value.location) +
        FfiConverterOptionalInt64.allocationSize(value.timestamp) +
        FfiConverterOptionalInt64.allocationSize(value.lastModified) +
        FfiConverterOptionalInt64.allocationSize(value.created) +
        FfiConverterOptionalInt64.allocationSize(value.start) +
        FfiConverterOptionalInt64.allocationSize(value.end)
      );
    }
  }
  return new FFIConverter();
})();

export type Email = {
  from: EmailAddressWithText;
  fromAddresses: Array<EmailAddress>;
  to: EmailAddressWithText;
  toAddresses: Array<EmailAddress>;
  ccAddresses: Array<EmailAddress>;
  bccAddresses: Array<EmailAddress>;
  subject: string | undefined;
  /**
   * Unix epoch in seconds
   */
  date: /*i64*/ bigint | undefined;
  contentId: string | undefined;
  messageId: string | undefined;
  threadName: string | undefined;
  mimeVersion: string | undefined;
  headers: Array<Header>;
  textBodies: Array<EmailText>;
  htmlBodies: Array<EmailText>;
  markups: Array<string>;
  calendarEvents: Array<CalendarEvent>;
  microdataItems: Array<MicrodataItem>;
  unsubscribe: Unsubscribe;
};

/**
 * Generated factory for {@link Email} record objects.
 */
export const Email = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<Email, ReturnType<typeof defaults>>(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link Email}, with defaults specified
     * in Rust, in the {@link vella_sdk} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link Email}, with defaults specified
     * in Rust, in the {@link vella_sdk} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link vella_sdk} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<Email>,
  });
})();

const FfiConverterTypeEmail = (() => {
  type TypeName = Email;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        from: FfiConverterTypeEmailAddressWithText.read(from),
        fromAddresses: FfiConverterArrayTypeEmailAddress.read(from),
        to: FfiConverterTypeEmailAddressWithText.read(from),
        toAddresses: FfiConverterArrayTypeEmailAddress.read(from),
        ccAddresses: FfiConverterArrayTypeEmailAddress.read(from),
        bccAddresses: FfiConverterArrayTypeEmailAddress.read(from),
        subject: FfiConverterOptionalString.read(from),
        date: FfiConverterOptionalInt64.read(from),
        contentId: FfiConverterOptionalString.read(from),
        messageId: FfiConverterOptionalString.read(from),
        threadName: FfiConverterOptionalString.read(from),
        mimeVersion: FfiConverterOptionalString.read(from),
        headers: FfiConverterArrayTypeHeader.read(from),
        textBodies: FfiConverterArrayTypeEmailText.read(from),
        htmlBodies: FfiConverterArrayTypeEmailText.read(from),
        markups: FfiConverterArrayString.read(from),
        calendarEvents: FfiConverterArrayTypeCalendarEvent.read(from),
        microdataItems: FfiConverterArrayTypeMicrodataItem.read(from),
        unsubscribe: FfiConverterTypeUnsubscribe.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterTypeEmailAddressWithText.write(value.from, into);
      FfiConverterArrayTypeEmailAddress.write(value.fromAddresses, into);
      FfiConverterTypeEmailAddressWithText.write(value.to, into);
      FfiConverterArrayTypeEmailAddress.write(value.toAddresses, into);
      FfiConverterArrayTypeEmailAddress.write(value.ccAddresses, into);
      FfiConverterArrayTypeEmailAddress.write(value.bccAddresses, into);
      FfiConverterOptionalString.write(value.subject, into);
      FfiConverterOptionalInt64.write(value.date, into);
      FfiConverterOptionalString.write(value.contentId, into);
      FfiConverterOptionalString.write(value.messageId, into);
      FfiConverterOptionalString.write(value.threadName, into);
      FfiConverterOptionalString.write(value.mimeVersion, into);
      FfiConverterArrayTypeHeader.write(value.headers, into);
      FfiConverterArrayTypeEmailText.write(value.textBodies, into);
      FfiConverterArrayTypeEmailText.write(value.htmlBodies, into);
      FfiConverterArrayString.write(value.markups, into);
      FfiConverterArrayTypeCalendarEvent.write(value.calendarEvents, into);
      FfiConverterArrayTypeMicrodataItem.write(value.microdataItems, into);
      FfiConverterTypeUnsubscribe.write(value.unsubscribe, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterTypeEmailAddressWithText.allocationSize(value.from) +
        FfiConverterArrayTypeEmailAddress.allocationSize(value.fromAddresses) +
        FfiConverterTypeEmailAddressWithText.allocationSize(value.to) +
        FfiConverterArrayTypeEmailAddress.allocationSize(value.toAddresses) +
        FfiConverterArrayTypeEmailAddress.allocationSize(value.ccAddresses) +
        FfiConverterArrayTypeEmailAddress.allocationSize(value.bccAddresses) +
        FfiConverterOptionalString.allocationSize(value.subject) +
        FfiConverterOptionalInt64.allocationSize(value.date) +
        FfiConverterOptionalString.allocationSize(value.contentId) +
        FfiConverterOptionalString.allocationSize(value.messageId) +
        FfiConverterOptionalString.allocationSize(value.threadName) +
        FfiConverterOptionalString.allocationSize(value.mimeVersion) +
        FfiConverterArrayTypeHeader.allocationSize(value.headers) +
        FfiConverterArrayTypeEmailText.allocationSize(value.textBodies) +
        FfiConverterArrayTypeEmailText.allocationSize(value.htmlBodies) +
        FfiConverterArrayString.allocationSize(value.markups) +
        FfiConverterArrayTypeCalendarEvent.allocationSize(
          value.calendarEvents
        ) +
        FfiConverterArrayTypeMicrodataItem.allocationSize(
          value.microdataItems
        ) +
        FfiConverterTypeUnsubscribe.allocationSize(value.unsubscribe)
      );
    }
  }
  return new FFIConverter();
})();

export type EmailAddress = {
  name: string | undefined;
  address: string;
};

/**
 * Generated factory for {@link EmailAddress} record objects.
 */
export const EmailAddress = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<EmailAddress, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link EmailAddress}, with defaults specified
     * in Rust, in the {@link vella_sdk} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link EmailAddress}, with defaults specified
     * in Rust, in the {@link vella_sdk} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link vella_sdk} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<EmailAddress>,
  });
})();

const FfiConverterTypeEmailAddress = (() => {
  type TypeName = EmailAddress;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        name: FfiConverterOptionalString.read(from),
        address: FfiConverterString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterOptionalString.write(value.name, into);
      FfiConverterString.write(value.address, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterOptionalString.allocationSize(value.name) +
        FfiConverterString.allocationSize(value.address)
      );
    }
  }
  return new FFIConverter();
})();

export type EmailAddressWithText = {
  name: string | undefined;
  text: string;
  address: string;
};

/**
 * Generated factory for {@link EmailAddressWithText} record objects.
 */
export const EmailAddressWithText = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<
      EmailAddressWithText,
      ReturnType<typeof defaults>
    >(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link EmailAddressWithText}, with defaults specified
     * in Rust, in the {@link vella_sdk} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link EmailAddressWithText}, with defaults specified
     * in Rust, in the {@link vella_sdk} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link vella_sdk} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<EmailAddressWithText>,
  });
})();

const FfiConverterTypeEmailAddressWithText = (() => {
  type TypeName = EmailAddressWithText;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        name: FfiConverterOptionalString.read(from),
        text: FfiConverterString.read(from),
        address: FfiConverterString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterOptionalString.write(value.name, into);
      FfiConverterString.write(value.text, into);
      FfiConverterString.write(value.address, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterOptionalString.allocationSize(value.name) +
        FfiConverterString.allocationSize(value.text) +
        FfiConverterString.allocationSize(value.address)
      );
    }
  }
  return new FFIConverter();
})();

export type EmailText = {
  text: string;
  visible: string | undefined;
};

/**
 * Generated factory for {@link EmailText} record objects.
 */
export const EmailText = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<EmailText, ReturnType<typeof defaults>>(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link EmailText}, with defaults specified
     * in Rust, in the {@link vella_sdk} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link EmailText}, with defaults specified
     * in Rust, in the {@link vella_sdk} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link vella_sdk} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<EmailText>,
  });
})();

const FfiConverterTypeEmailText = (() => {
  type TypeName = EmailText;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        text: FfiConverterString.read(from),
        visible: FfiConverterOptionalString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.text, into);
      FfiConverterOptionalString.write(value.visible, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.text) +
        FfiConverterOptionalString.allocationSize(value.visible)
      );
    }
  }
  return new FFIConverter();
})();

export type GmailError = {
  code: /*u32*/ number;
  message: string;
  status: string;
  errors: Array<GmailErrorItem>;
};

/**
 * Generated factory for {@link GmailError} record objects.
 */
export const GmailError = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<GmailError, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link GmailError}, with defaults specified
     * in Rust, in the {@link vella_sdk} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link GmailError}, with defaults specified
     * in Rust, in the {@link vella_sdk} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link vella_sdk} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<GmailError>,
  });
})();

const FfiConverterTypeGmailError = (() => {
  type TypeName = GmailError;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        code: FfiConverterUInt32.read(from),
        message: FfiConverterString.read(from),
        status: FfiConverterString.read(from),
        errors: FfiConverterArrayTypeGmailErrorItem.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterUInt32.write(value.code, into);
      FfiConverterString.write(value.message, into);
      FfiConverterString.write(value.status, into);
      FfiConverterArrayTypeGmailErrorItem.write(value.errors, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterUInt32.allocationSize(value.code) +
        FfiConverterString.allocationSize(value.message) +
        FfiConverterString.allocationSize(value.status) +
        FfiConverterArrayTypeGmailErrorItem.allocationSize(value.errors)
      );
    }
  }
  return new FFIConverter();
})();

export type GmailErrorItem = {
  message: string;
  domain: string;
  reason: string;
};

/**
 * Generated factory for {@link GmailErrorItem} record objects.
 */
export const GmailErrorItem = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<GmailErrorItem, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link GmailErrorItem}, with defaults specified
     * in Rust, in the {@link vella_sdk} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link GmailErrorItem}, with defaults specified
     * in Rust, in the {@link vella_sdk} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link vella_sdk} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<GmailErrorItem>,
  });
})();

const FfiConverterTypeGmailErrorItem = (() => {
  type TypeName = GmailErrorItem;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        message: FfiConverterString.read(from),
        domain: FfiConverterString.read(from),
        reason: FfiConverterString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.message, into);
      FfiConverterString.write(value.domain, into);
      FfiConverterString.write(value.reason, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.message) +
        FfiConverterString.allocationSize(value.domain) +
        FfiConverterString.allocationSize(value.reason)
      );
    }
  }
  return new FFIConverter();
})();

export type GmailMessage = {
  id: string;
  threadId: string;
  labelIds: Array<string>;
  snippet: EmailText;
  sizeEstimate: /*u32*/ number;
  data: Email;
  historyId: string;
  internalDate: string;
};

/**
 * Generated factory for {@link GmailMessage} record objects.
 */
export const GmailMessage = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<GmailMessage, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link GmailMessage}, with defaults specified
     * in Rust, in the {@link vella_sdk} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link GmailMessage}, with defaults specified
     * in Rust, in the {@link vella_sdk} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link vella_sdk} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<GmailMessage>,
  });
})();

const FfiConverterTypeGmailMessage = (() => {
  type TypeName = GmailMessage;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        id: FfiConverterString.read(from),
        threadId: FfiConverterString.read(from),
        labelIds: FfiConverterArrayString.read(from),
        snippet: FfiConverterTypeEmailText.read(from),
        sizeEstimate: FfiConverterUInt32.read(from),
        data: FfiConverterTypeEmail.read(from),
        historyId: FfiConverterString.read(from),
        internalDate: FfiConverterString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.id, into);
      FfiConverterString.write(value.threadId, into);
      FfiConverterArrayString.write(value.labelIds, into);
      FfiConverterTypeEmailText.write(value.snippet, into);
      FfiConverterUInt32.write(value.sizeEstimate, into);
      FfiConverterTypeEmail.write(value.data, into);
      FfiConverterString.write(value.historyId, into);
      FfiConverterString.write(value.internalDate, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.id) +
        FfiConverterString.allocationSize(value.threadId) +
        FfiConverterArrayString.allocationSize(value.labelIds) +
        FfiConverterTypeEmailText.allocationSize(value.snippet) +
        FfiConverterUInt32.allocationSize(value.sizeEstimate) +
        FfiConverterTypeEmail.allocationSize(value.data) +
        FfiConverterString.allocationSize(value.historyId) +
        FfiConverterString.allocationSize(value.internalDate)
      );
    }
  }
  return new FFIConverter();
})();

export type Header = {
  name: string;
  value: string;
};

/**
 * Generated factory for {@link Header} record objects.
 */
export const Header = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<Header, ReturnType<typeof defaults>>(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link Header}, with defaults specified
     * in Rust, in the {@link vella_sdk} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link Header}, with defaults specified
     * in Rust, in the {@link vella_sdk} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link vella_sdk} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<Header>,
  });
})();

const FfiConverterTypeHeader = (() => {
  type TypeName = Header;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        name: FfiConverterString.read(from),
        value: FfiConverterString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.name, into);
      FfiConverterString.write(value.value, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.name) +
        FfiConverterString.allocationSize(value.value)
      );
    }
  }
  return new FFIConverter();
})();

export type MicrodataItem = {
  itemtype: string | undefined;
  properties: Map<string, string>;
  children: Map<string, MicrodataItem>;
};

/**
 * Generated factory for {@link MicrodataItem} record objects.
 */
export const MicrodataItem = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<MicrodataItem, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link MicrodataItem}, with defaults specified
     * in Rust, in the {@link vella_sdk} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link MicrodataItem}, with defaults specified
     * in Rust, in the {@link vella_sdk} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link vella_sdk} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<MicrodataItem>,
  });
})();

const FfiConverterTypeMicrodataItem = (() => {
  type TypeName = MicrodataItem;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        itemtype: FfiConverterOptionalString.read(from),
        properties: FfiConverterMapStringString.read(from),
        children: FfiConverterMapStringTypeMicrodataItem.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterOptionalString.write(value.itemtype, into);
      FfiConverterMapStringString.write(value.properties, into);
      FfiConverterMapStringTypeMicrodataItem.write(value.children, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterOptionalString.allocationSize(value.itemtype) +
        FfiConverterMapStringString.allocationSize(value.properties) +
        FfiConverterMapStringTypeMicrodataItem.allocationSize(value.children)
      );
    }
  }
  return new FFIConverter();
})();

export type PaddingParams = {
  strategy: PaddingStrategy;
  direction: PaddingDirection;
  padToMultipleOf: /*u32*/ number | undefined;
  padId: /*u32*/ number;
  padTypeId: /*u32*/ number;
  padToken: string;
};

/**
 * Generated factory for {@link PaddingParams} record objects.
 */
export const PaddingParams = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<PaddingParams, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link PaddingParams}, with defaults specified
     * in Rust, in the {@link vella_sdk} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link PaddingParams}, with defaults specified
     * in Rust, in the {@link vella_sdk} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link vella_sdk} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<PaddingParams>,
  });
})();

const FfiConverterTypePaddingParams = (() => {
  type TypeName = PaddingParams;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        strategy: FfiConverterTypePaddingStrategy.read(from),
        direction: FfiConverterTypePaddingDirection.read(from),
        padToMultipleOf: FfiConverterOptionalUInt32.read(from),
        padId: FfiConverterUInt32.read(from),
        padTypeId: FfiConverterUInt32.read(from),
        padToken: FfiConverterString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterTypePaddingStrategy.write(value.strategy, into);
      FfiConverterTypePaddingDirection.write(value.direction, into);
      FfiConverterOptionalUInt32.write(value.padToMultipleOf, into);
      FfiConverterUInt32.write(value.padId, into);
      FfiConverterUInt32.write(value.padTypeId, into);
      FfiConverterString.write(value.padToken, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterTypePaddingStrategy.allocationSize(value.strategy) +
        FfiConverterTypePaddingDirection.allocationSize(value.direction) +
        FfiConverterOptionalUInt32.allocationSize(value.padToMultipleOf) +
        FfiConverterUInt32.allocationSize(value.padId) +
        FfiConverterUInt32.allocationSize(value.padTypeId) +
        FfiConverterString.allocationSize(value.padToken)
      );
    }
  }
  return new FFIConverter();
})();

export type ReturnToken = {
  id: /*u32*/ number;
  token: string;
};

/**
 * Generated factory for {@link ReturnToken} record objects.
 */
export const ReturnToken = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<ReturnToken, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link ReturnToken}, with defaults specified
     * in Rust, in the {@link vella_sdk} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link ReturnToken}, with defaults specified
     * in Rust, in the {@link vella_sdk} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link vella_sdk} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<ReturnToken>,
  });
})();

const FfiConverterTypeReturnToken = (() => {
  type TypeName = ReturnToken;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        id: FfiConverterUInt32.read(from),
        token: FfiConverterString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterUInt32.write(value.id, into);
      FfiConverterString.write(value.token, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterUInt32.allocationSize(value.id) +
        FfiConverterString.allocationSize(value.token)
      );
    }
  }
  return new FFIConverter();
})();

export type Token = {
  id: /*u32*/ number;
  token: string;
  start: /*u32*/ number;
  end: /*u32*/ number;
};

/**
 * Generated factory for {@link Token} record objects.
 */
export const Token = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<Token, ReturnType<typeof defaults>>(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link Token}, with defaults specified
     * in Rust, in the {@link vella_sdk} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link Token}, with defaults specified
     * in Rust, in the {@link vella_sdk} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link vella_sdk} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<Token>,
  });
})();

const FfiConverterTypeToken = (() => {
  type TypeName = Token;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        id: FfiConverterUInt32.read(from),
        token: FfiConverterString.read(from),
        start: FfiConverterUInt32.read(from),
        end: FfiConverterUInt32.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterUInt32.write(value.id, into);
      FfiConverterString.write(value.token, into);
      FfiConverterUInt32.write(value.start, into);
      FfiConverterUInt32.write(value.end, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterUInt32.allocationSize(value.id) +
        FfiConverterString.allocationSize(value.token) +
        FfiConverterUInt32.allocationSize(value.start) +
        FfiConverterUInt32.allocationSize(value.end)
      );
    }
  }
  return new FFIConverter();
})();

export type TokenizedBatch = {
  tokenIds: Array<Array</*u32*/ number>>;
  attentionMask: Array<Array</*u32*/ number>>;
  typeIds: Array<Array</*u32*/ number>>;
};

/**
 * Generated factory for {@link TokenizedBatch} record objects.
 */
export const TokenizedBatch = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<TokenizedBatch, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link TokenizedBatch}, with defaults specified
     * in Rust, in the {@link vella_sdk} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link TokenizedBatch}, with defaults specified
     * in Rust, in the {@link vella_sdk} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link vella_sdk} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<TokenizedBatch>,
  });
})();

const FfiConverterTypeTokenizedBatch = (() => {
  type TypeName = TokenizedBatch;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        tokenIds: FfiConverterArrayArrayUInt32.read(from),
        attentionMask: FfiConverterArrayArrayUInt32.read(from),
        typeIds: FfiConverterArrayArrayUInt32.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterArrayArrayUInt32.write(value.tokenIds, into);
      FfiConverterArrayArrayUInt32.write(value.attentionMask, into);
      FfiConverterArrayArrayUInt32.write(value.typeIds, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterArrayArrayUInt32.allocationSize(value.tokenIds) +
        FfiConverterArrayArrayUInt32.allocationSize(value.attentionMask) +
        FfiConverterArrayArrayUInt32.allocationSize(value.typeIds)
      );
    }
  }
  return new FFIConverter();
})();

export type TruncationParams = {
  direction: TruncationDirection;
  maxLength: /*u32*/ number;
  strategy: TruncationStrategy;
  stride: /*u32*/ number;
};

/**
 * Generated factory for {@link TruncationParams} record objects.
 */
export const TruncationParams = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<TruncationParams, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link TruncationParams}, with defaults specified
     * in Rust, in the {@link vella_sdk} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link TruncationParams}, with defaults specified
     * in Rust, in the {@link vella_sdk} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link vella_sdk} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<TruncationParams>,
  });
})();

const FfiConverterTypeTruncationParams = (() => {
  type TypeName = TruncationParams;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        direction: FfiConverterTypeTruncationDirection.read(from),
        maxLength: FfiConverterUInt32.read(from),
        strategy: FfiConverterTypeTruncationStrategy.read(from),
        stride: FfiConverterUInt32.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterTypeTruncationDirection.write(value.direction, into);
      FfiConverterUInt32.write(value.maxLength, into);
      FfiConverterTypeTruncationStrategy.write(value.strategy, into);
      FfiConverterUInt32.write(value.stride, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterTypeTruncationDirection.allocationSize(value.direction) +
        FfiConverterUInt32.allocationSize(value.maxLength) +
        FfiConverterTypeTruncationStrategy.allocationSize(value.strategy) +
        FfiConverterUInt32.allocationSize(value.stride)
      );
    }
  }
  return new FFIConverter();
})();

export type Unsubscribe = {
  get: string | undefined;
  post: UnsubscribePost | undefined;
  email: UnsubscribeEmail | undefined;
};

/**
 * Generated factory for {@link Unsubscribe} record objects.
 */
export const Unsubscribe = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<Unsubscribe, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link Unsubscribe}, with defaults specified
     * in Rust, in the {@link vella_sdk} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link Unsubscribe}, with defaults specified
     * in Rust, in the {@link vella_sdk} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link vella_sdk} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<Unsubscribe>,
  });
})();

const FfiConverterTypeUnsubscribe = (() => {
  type TypeName = Unsubscribe;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        get: FfiConverterOptionalString.read(from),
        post: FfiConverterOptionalTypeUnsubscribePost.read(from),
        email: FfiConverterOptionalTypeUnsubscribeEmail.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterOptionalString.write(value.get, into);
      FfiConverterOptionalTypeUnsubscribePost.write(value.post, into);
      FfiConverterOptionalTypeUnsubscribeEmail.write(value.email, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterOptionalString.allocationSize(value.get) +
        FfiConverterOptionalTypeUnsubscribePost.allocationSize(value.post) +
        FfiConverterOptionalTypeUnsubscribeEmail.allocationSize(value.email)
      );
    }
  }
  return new FFIConverter();
})();

export type UnsubscribeEmail = {
  email: string;
  headers: Array<Header>;
};

/**
 * Generated factory for {@link UnsubscribeEmail} record objects.
 */
export const UnsubscribeEmail = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<UnsubscribeEmail, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link UnsubscribeEmail}, with defaults specified
     * in Rust, in the {@link vella_sdk} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link UnsubscribeEmail}, with defaults specified
     * in Rust, in the {@link vella_sdk} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link vella_sdk} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<UnsubscribeEmail>,
  });
})();

const FfiConverterTypeUnsubscribeEmail = (() => {
  type TypeName = UnsubscribeEmail;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        email: FfiConverterString.read(from),
        headers: FfiConverterArrayTypeHeader.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.email, into);
      FfiConverterArrayTypeHeader.write(value.headers, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.email) +
        FfiConverterArrayTypeHeader.allocationSize(value.headers)
      );
    }
  }
  return new FFIConverter();
})();

export type UnsubscribePost = {
  url: string;
  body: string;
};

/**
 * Generated factory for {@link UnsubscribePost} record objects.
 */
export const UnsubscribePost = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<UnsubscribePost, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link UnsubscribePost}, with defaults specified
     * in Rust, in the {@link vella_sdk} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link UnsubscribePost}, with defaults specified
     * in Rust, in the {@link vella_sdk} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link vella_sdk} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<UnsubscribePost>,
  });
})();

const FfiConverterTypeUnsubscribePost = (() => {
  type TypeName = UnsubscribePost;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        url: FfiConverterString.read(from),
        body: FfiConverterString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.url, into);
      FfiConverterString.write(value.body, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.url) +
        FfiConverterString.allocationSize(value.body)
      );
    }
  }
  return new FFIConverter();
})();

const stringConverter = {
  stringToBytes: (s: string) =>
    uniffiCaller.rustCall((status) =>
      nativeModule().ubrn_uniffi_internal_fn_func_ffi__string_to_arraybuffer(
        s,
        status
      )
    ),
  bytesToString: (ab: UniffiByteArray) =>
    uniffiCaller.rustCall((status) =>
      nativeModule().ubrn_uniffi_internal_fn_func_ffi__arraybuffer_to_string(
        ab,
        status
      )
    ),
  stringByteLength: (s: string) =>
    uniffiCaller.rustCall((status) =>
      nativeModule().ubrn_uniffi_internal_fn_func_ffi__string_to_byte_length(
        s,
        status
      )
    ),
};
const FfiConverterString = uniffiCreateFfiConverterString(stringConverter);

// Enum: BatchResponse
export enum BatchResponse_Tags {
  Success = 'Success',
  Error = 'Error',
}
export const BatchResponse = (() => {
  type Success__interface = {
    tag: BatchResponse_Tags.Success;
    inner: Readonly<[GmailMessage]>;
  };

  class Success_ extends UniffiEnum implements Success__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'BatchResponse';
    readonly tag = BatchResponse_Tags.Success;
    readonly inner: Readonly<[GmailMessage]>;
    constructor(v0: GmailMessage) {
      super('BatchResponse', 'Success');
      this.inner = Object.freeze([v0]);
    }

    static new(v0: GmailMessage): Success_ {
      return new Success_(v0);
    }

    static instanceOf(obj: any): obj is Success_ {
      return obj.tag === BatchResponse_Tags.Success;
    }
  }

  type Error__interface = {
    tag: BatchResponse_Tags.Error;
    inner: Readonly<[GmailError]>;
  };

  class Error_ extends UniffiEnum implements Error__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'BatchResponse';
    readonly tag = BatchResponse_Tags.Error;
    readonly inner: Readonly<[GmailError]>;
    constructor(v0: GmailError) {
      super('BatchResponse', 'Error');
      this.inner = Object.freeze([v0]);
    }

    static new(v0: GmailError): Error_ {
      return new Error_(v0);
    }

    static instanceOf(obj: any): obj is Error_ {
      return obj.tag === BatchResponse_Tags.Error;
    }
  }

  function instanceOf(obj: any): obj is BatchResponse {
    return obj[uniffiTypeNameSymbol] === 'BatchResponse';
  }

  return Object.freeze({
    instanceOf,
    Success: Success_,
    Error: Error_,
  });
})();

export type BatchResponse = InstanceType<
  (typeof BatchResponse)[keyof Omit<typeof BatchResponse, 'instanceOf'>]
>;

// FfiConverter for enum BatchResponse
const FfiConverterTypeBatchResponse = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = BatchResponse;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new BatchResponse.Success(
            FfiConverterTypeGmailMessage.read(from)
          );
        case 2:
          return new BatchResponse.Error(FfiConverterTypeGmailError.read(from));
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case BatchResponse_Tags.Success: {
          ordinalConverter.write(1, into);
          const inner = value.inner;
          FfiConverterTypeGmailMessage.write(inner[0], into);
          return;
        }
        case BatchResponse_Tags.Error: {
          ordinalConverter.write(2, into);
          const inner = value.inner;
          FfiConverterTypeGmailError.write(inner[0], into);
          return;
        }
        default:
          // Throwing from here means that BatchResponse_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case BatchResponse_Tags.Success: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(1);
          size += FfiConverterTypeGmailMessage.allocationSize(inner[0]);
          return size;
        }
        case BatchResponse_Tags.Error: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(2);
          size += FfiConverterTypeGmailError.allocationSize(inner[0]);
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

export enum CalendarEventStatus {
  /**
   * Indicates event is tentative.
   */
  Tentative,
  /**
   * Indicates event is definite.
   */
  Confirmed,
  /**
   * Indicates event was cancelled.
   */
  Cancelled,
}

const FfiConverterTypeCalendarEventStatus = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = CalendarEventStatus;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return CalendarEventStatus.Tentative;
        case 2:
          return CalendarEventStatus.Confirmed;
        case 3:
          return CalendarEventStatus.Cancelled;
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value) {
        case CalendarEventStatus.Tentative:
          return ordinalConverter.write(1, into);
        case CalendarEventStatus.Confirmed:
          return ordinalConverter.write(2, into);
        case CalendarEventStatus.Cancelled:
          return ordinalConverter.write(3, into);
      }
    }
    allocationSize(value: TypeName): number {
      return ordinalConverter.allocationSize(0);
    }
  }
  return new FFIConverter();
})();

export enum PaddingDirection {
  Left,
  Right,
}

const FfiConverterTypePaddingDirection = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = PaddingDirection;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return PaddingDirection.Left;
        case 2:
          return PaddingDirection.Right;
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value) {
        case PaddingDirection.Left:
          return ordinalConverter.write(1, into);
        case PaddingDirection.Right:
          return ordinalConverter.write(2, into);
      }
    }
    allocationSize(value: TypeName): number {
      return ordinalConverter.allocationSize(0);
    }
  }
  return new FFIConverter();
})();

// Enum: PaddingStrategy
export enum PaddingStrategy_Tags {
  BatchLongest = 'BatchLongest',
  Fixed = 'Fixed',
}
export const PaddingStrategy = (() => {
  type BatchLongest__interface = {
    tag: PaddingStrategy_Tags.BatchLongest;
  };

  class BatchLongest_ extends UniffiEnum implements BatchLongest__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'PaddingStrategy';
    readonly tag = PaddingStrategy_Tags.BatchLongest;
    constructor() {
      super('PaddingStrategy', 'BatchLongest');
    }

    static new(): BatchLongest_ {
      return new BatchLongest_();
    }

    static instanceOf(obj: any): obj is BatchLongest_ {
      return obj.tag === PaddingStrategy_Tags.BatchLongest;
    }
  }

  type Fixed__interface = {
    tag: PaddingStrategy_Tags.Fixed;
    inner: Readonly<[/*u32*/ number]>;
  };

  class Fixed_ extends UniffiEnum implements Fixed__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'PaddingStrategy';
    readonly tag = PaddingStrategy_Tags.Fixed;
    readonly inner: Readonly<[/*u32*/ number]>;
    constructor(v0: /*u32*/ number) {
      super('PaddingStrategy', 'Fixed');
      this.inner = Object.freeze([v0]);
    }

    static new(v0: /*u32*/ number): Fixed_ {
      return new Fixed_(v0);
    }

    static instanceOf(obj: any): obj is Fixed_ {
      return obj.tag === PaddingStrategy_Tags.Fixed;
    }
  }

  function instanceOf(obj: any): obj is PaddingStrategy {
    return obj[uniffiTypeNameSymbol] === 'PaddingStrategy';
  }

  return Object.freeze({
    instanceOf,
    BatchLongest: BatchLongest_,
    Fixed: Fixed_,
  });
})();

export type PaddingStrategy = InstanceType<
  (typeof PaddingStrategy)[keyof Omit<typeof PaddingStrategy, 'instanceOf'>]
>;

// FfiConverter for enum PaddingStrategy
const FfiConverterTypePaddingStrategy = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = PaddingStrategy;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new PaddingStrategy.BatchLongest();
        case 2:
          return new PaddingStrategy.Fixed(FfiConverterUInt32.read(from));
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case PaddingStrategy_Tags.BatchLongest: {
          ordinalConverter.write(1, into);
          return;
        }
        case PaddingStrategy_Tags.Fixed: {
          ordinalConverter.write(2, into);
          const inner = value.inner;
          FfiConverterUInt32.write(inner[0], into);
          return;
        }
        default:
          // Throwing from here means that PaddingStrategy_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case PaddingStrategy_Tags.BatchLongest: {
          return ordinalConverter.allocationSize(1);
        }
        case PaddingStrategy_Tags.Fixed: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(2);
          size += FfiConverterUInt32.allocationSize(inner[0]);
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

// Error type: ParserError

// Enum: ParserError
export enum ParserError_Tags {
  Base64DecodeFailed = 'Base64DecodeFailed',
  NonUtfInput = 'NonUtfInput',
  EmptyInput = 'EmptyInput',
  EmailParseFailed = 'EmailParseFailed',
  NoFromHeader = 'NoFromHeader',
  NoToHeader = 'NoToHeader',
}
export const ParserError = (() => {
  type Base64DecodeFailed__interface = {
    tag: ParserError_Tags.Base64DecodeFailed;
  };

  class Base64DecodeFailed_
    extends UniffiError
    implements Base64DecodeFailed__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'ParserError';
    readonly tag = ParserError_Tags.Base64DecodeFailed;
    constructor() {
      super('ParserError', 'Base64DecodeFailed');
    }

    static new(): Base64DecodeFailed_ {
      return new Base64DecodeFailed_();
    }

    static instanceOf(obj: any): obj is Base64DecodeFailed_ {
      return obj.tag === ParserError_Tags.Base64DecodeFailed;
    }

    static hasInner(obj: any): obj is Base64DecodeFailed_ {
      return false;
    }
  }

  type NonUtfInput__interface = {
    tag: ParserError_Tags.NonUtfInput;
  };

  class NonUtfInput_ extends UniffiError implements NonUtfInput__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'ParserError';
    readonly tag = ParserError_Tags.NonUtfInput;
    constructor() {
      super('ParserError', 'NonUtfInput');
    }

    static new(): NonUtfInput_ {
      return new NonUtfInput_();
    }

    static instanceOf(obj: any): obj is NonUtfInput_ {
      return obj.tag === ParserError_Tags.NonUtfInput;
    }

    static hasInner(obj: any): obj is NonUtfInput_ {
      return false;
    }
  }

  type EmptyInput__interface = {
    tag: ParserError_Tags.EmptyInput;
  };

  class EmptyInput_ extends UniffiError implements EmptyInput__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'ParserError';
    readonly tag = ParserError_Tags.EmptyInput;
    constructor() {
      super('ParserError', 'EmptyInput');
    }

    static new(): EmptyInput_ {
      return new EmptyInput_();
    }

    static instanceOf(obj: any): obj is EmptyInput_ {
      return obj.tag === ParserError_Tags.EmptyInput;
    }

    static hasInner(obj: any): obj is EmptyInput_ {
      return false;
    }
  }

  type EmailParseFailed__interface = {
    tag: ParserError_Tags.EmailParseFailed;
  };

  class EmailParseFailed_
    extends UniffiError
    implements EmailParseFailed__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'ParserError';
    readonly tag = ParserError_Tags.EmailParseFailed;
    constructor() {
      super('ParserError', 'EmailParseFailed');
    }

    static new(): EmailParseFailed_ {
      return new EmailParseFailed_();
    }

    static instanceOf(obj: any): obj is EmailParseFailed_ {
      return obj.tag === ParserError_Tags.EmailParseFailed;
    }

    static hasInner(obj: any): obj is EmailParseFailed_ {
      return false;
    }
  }

  type NoFromHeader__interface = {
    tag: ParserError_Tags.NoFromHeader;
  };

  class NoFromHeader_ extends UniffiError implements NoFromHeader__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'ParserError';
    readonly tag = ParserError_Tags.NoFromHeader;
    constructor() {
      super('ParserError', 'NoFromHeader');
    }

    static new(): NoFromHeader_ {
      return new NoFromHeader_();
    }

    static instanceOf(obj: any): obj is NoFromHeader_ {
      return obj.tag === ParserError_Tags.NoFromHeader;
    }

    static hasInner(obj: any): obj is NoFromHeader_ {
      return false;
    }
  }

  type NoToHeader__interface = {
    tag: ParserError_Tags.NoToHeader;
  };

  class NoToHeader_ extends UniffiError implements NoToHeader__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'ParserError';
    readonly tag = ParserError_Tags.NoToHeader;
    constructor() {
      super('ParserError', 'NoToHeader');
    }

    static new(): NoToHeader_ {
      return new NoToHeader_();
    }

    static instanceOf(obj: any): obj is NoToHeader_ {
      return obj.tag === ParserError_Tags.NoToHeader;
    }

    static hasInner(obj: any): obj is NoToHeader_ {
      return false;
    }
  }

  function instanceOf(obj: any): obj is ParserError {
    return obj[uniffiTypeNameSymbol] === 'ParserError';
  }

  return Object.freeze({
    instanceOf,
    Base64DecodeFailed: Base64DecodeFailed_,
    NonUtfInput: NonUtfInput_,
    EmptyInput: EmptyInput_,
    EmailParseFailed: EmailParseFailed_,
    NoFromHeader: NoFromHeader_,
    NoToHeader: NoToHeader_,
  });
})();

export type ParserError = InstanceType<
  (typeof ParserError)[keyof Omit<typeof ParserError, 'instanceOf'>]
>;

// FfiConverter for enum ParserError
const FfiConverterTypeParserError = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = ParserError;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new ParserError.Base64DecodeFailed();
        case 2:
          return new ParserError.NonUtfInput();
        case 3:
          return new ParserError.EmptyInput();
        case 4:
          return new ParserError.EmailParseFailed();
        case 5:
          return new ParserError.NoFromHeader();
        case 6:
          return new ParserError.NoToHeader();
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case ParserError_Tags.Base64DecodeFailed: {
          ordinalConverter.write(1, into);
          return;
        }
        case ParserError_Tags.NonUtfInput: {
          ordinalConverter.write(2, into);
          return;
        }
        case ParserError_Tags.EmptyInput: {
          ordinalConverter.write(3, into);
          return;
        }
        case ParserError_Tags.EmailParseFailed: {
          ordinalConverter.write(4, into);
          return;
        }
        case ParserError_Tags.NoFromHeader: {
          ordinalConverter.write(5, into);
          return;
        }
        case ParserError_Tags.NoToHeader: {
          ordinalConverter.write(6, into);
          return;
        }
        default:
          // Throwing from here means that ParserError_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case ParserError_Tags.Base64DecodeFailed: {
          return ordinalConverter.allocationSize(1);
        }
        case ParserError_Tags.NonUtfInput: {
          return ordinalConverter.allocationSize(2);
        }
        case ParserError_Tags.EmptyInput: {
          return ordinalConverter.allocationSize(3);
        }
        case ParserError_Tags.EmailParseFailed: {
          return ordinalConverter.allocationSize(4);
        }
        case ParserError_Tags.NoFromHeader: {
          return ordinalConverter.allocationSize(5);
        }
        case ParserError_Tags.NoToHeader: {
          return ordinalConverter.allocationSize(6);
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

export enum SpecialTokens {
  Yes,
  No,
}

const FfiConverterTypeSpecialTokens = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = SpecialTokens;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return SpecialTokens.Yes;
        case 2:
          return SpecialTokens.No;
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value) {
        case SpecialTokens.Yes:
          return ordinalConverter.write(1, into);
        case SpecialTokens.No:
          return ordinalConverter.write(2, into);
      }
    }
    allocationSize(value: TypeName): number {
      return ordinalConverter.allocationSize(0);
    }
  }
  return new FFIConverter();
})();

// Error type: TokenizeError

// Enum: TokenizeError
export enum TokenizeError_Tags {
  TokenizerCreationFailed = 'TokenizerCreationFailed',
  InputEncodingFailed = 'InputEncodingFailed',
  InvalidTruncationParams = 'InvalidTruncationParams',
}
export const TokenizeError = (() => {
  type TokenizerCreationFailed__interface = {
    tag: TokenizeError_Tags.TokenizerCreationFailed;
  };

  class TokenizerCreationFailed_
    extends UniffiError
    implements TokenizerCreationFailed__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'TokenizeError';
    readonly tag = TokenizeError_Tags.TokenizerCreationFailed;
    constructor() {
      super('TokenizeError', 'TokenizerCreationFailed');
    }

    static new(): TokenizerCreationFailed_ {
      return new TokenizerCreationFailed_();
    }

    static instanceOf(obj: any): obj is TokenizerCreationFailed_ {
      return obj.tag === TokenizeError_Tags.TokenizerCreationFailed;
    }

    static hasInner(obj: any): obj is TokenizerCreationFailed_ {
      return false;
    }
  }

  type InputEncodingFailed__interface = {
    tag: TokenizeError_Tags.InputEncodingFailed;
  };

  class InputEncodingFailed_
    extends UniffiError
    implements InputEncodingFailed__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'TokenizeError';
    readonly tag = TokenizeError_Tags.InputEncodingFailed;
    constructor() {
      super('TokenizeError', 'InputEncodingFailed');
    }

    static new(): InputEncodingFailed_ {
      return new InputEncodingFailed_();
    }

    static instanceOf(obj: any): obj is InputEncodingFailed_ {
      return obj.tag === TokenizeError_Tags.InputEncodingFailed;
    }

    static hasInner(obj: any): obj is InputEncodingFailed_ {
      return false;
    }
  }

  type InvalidTruncationParams__interface = {
    tag: TokenizeError_Tags.InvalidTruncationParams;
  };

  class InvalidTruncationParams_
    extends UniffiError
    implements InvalidTruncationParams__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'TokenizeError';
    readonly tag = TokenizeError_Tags.InvalidTruncationParams;
    constructor() {
      super('TokenizeError', 'InvalidTruncationParams');
    }

    static new(): InvalidTruncationParams_ {
      return new InvalidTruncationParams_();
    }

    static instanceOf(obj: any): obj is InvalidTruncationParams_ {
      return obj.tag === TokenizeError_Tags.InvalidTruncationParams;
    }

    static hasInner(obj: any): obj is InvalidTruncationParams_ {
      return false;
    }
  }

  function instanceOf(obj: any): obj is TokenizeError {
    return obj[uniffiTypeNameSymbol] === 'TokenizeError';
  }

  return Object.freeze({
    instanceOf,
    TokenizerCreationFailed: TokenizerCreationFailed_,
    InputEncodingFailed: InputEncodingFailed_,
    InvalidTruncationParams: InvalidTruncationParams_,
  });
})();

export type TokenizeError = InstanceType<
  (typeof TokenizeError)[keyof Omit<typeof TokenizeError, 'instanceOf'>]
>;

// FfiConverter for enum TokenizeError
const FfiConverterTypeTokenizeError = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = TokenizeError;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new TokenizeError.TokenizerCreationFailed();
        case 2:
          return new TokenizeError.InputEncodingFailed();
        case 3:
          return new TokenizeError.InvalidTruncationParams();
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case TokenizeError_Tags.TokenizerCreationFailed: {
          ordinalConverter.write(1, into);
          return;
        }
        case TokenizeError_Tags.InputEncodingFailed: {
          ordinalConverter.write(2, into);
          return;
        }
        case TokenizeError_Tags.InvalidTruncationParams: {
          ordinalConverter.write(3, into);
          return;
        }
        default:
          // Throwing from here means that TokenizeError_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case TokenizeError_Tags.TokenizerCreationFailed: {
          return ordinalConverter.allocationSize(1);
        }
        case TokenizeError_Tags.InputEncodingFailed: {
          return ordinalConverter.allocationSize(2);
        }
        case TokenizeError_Tags.InvalidTruncationParams: {
          return ordinalConverter.allocationSize(3);
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

export enum TruncationDirection {
  Left,
  Right,
}

const FfiConverterTypeTruncationDirection = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = TruncationDirection;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return TruncationDirection.Left;
        case 2:
          return TruncationDirection.Right;
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value) {
        case TruncationDirection.Left:
          return ordinalConverter.write(1, into);
        case TruncationDirection.Right:
          return ordinalConverter.write(2, into);
      }
    }
    allocationSize(value: TypeName): number {
      return ordinalConverter.allocationSize(0);
    }
  }
  return new FFIConverter();
})();

export enum TruncationStrategy {
  LongestFirst,
  OnlyFirst,
  OnlySecond,
}

const FfiConverterTypeTruncationStrategy = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = TruncationStrategy;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return TruncationStrategy.LongestFirst;
        case 2:
          return TruncationStrategy.OnlyFirst;
        case 3:
          return TruncationStrategy.OnlySecond;
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value) {
        case TruncationStrategy.LongestFirst:
          return ordinalConverter.write(1, into);
        case TruncationStrategy.OnlyFirst:
          return ordinalConverter.write(2, into);
        case TruncationStrategy.OnlySecond:
          return ordinalConverter.write(3, into);
      }
    }
    allocationSize(value: TypeName): number {
      return ordinalConverter.allocationSize(0);
    }
  }
  return new FFIConverter();
})();

// FfiConverter for Map<string, MicrodataItem>
const FfiConverterMapStringTypeMicrodataItem = new FfiConverterMap(
  FfiConverterString,
  FfiConverterTypeMicrodataItem
);

// FfiConverter for Map<string, string>
const FfiConverterMapStringString = new FfiConverterMap(
  FfiConverterString,
  FfiConverterString
);

/**
 * A tokenizer object from a custom dictionary.
 */
export interface CustomTokenizerInnerInterface {
  /**
   * Decode a given list of token ids, back to a string
   */
  decode(
    tokens: Array</*u32*/ number>,
    specialTokens: SpecialTokens
  ): string | undefined;
  /**
   * Tokenizes an input string and return a list of token IDs.
   */
  getIds(
    input: string,
    specialTokens: SpecialTokens
  ) /*throws*/ : Array</*u32*/ number>;
  /**
   * Gets the configured pad token.
   */
  getPadToken(): ReturnToken | undefined;
  /**
   * Tokenizes an input string and returns a list of token strings.
   */
  getTokens(
    input: string,
    specialTokens: SpecialTokens
  ) /*throws*/ : Array<string>;
  /**
   * Gets the string value of a given token ID.
   */
  idToToken(id: /*u32*/ number): string | undefined;
  /**
   * Gets the ID value of a given token.
   */
  tokenToId(token: string): /*u32*/ number | undefined;
  /**
   * Tokenizes an input string and returns a list of tokens.
   */
  tokenize(
    input: string,
    specialTokens: SpecialTokens
  ) /*throws*/ : Array<Token>;
  /**
   * Tokenizes a list of input strings and returns a list of token IDs.
   */
  tokenizeBatch(
    input: Array<string>,
    specialTokens: SpecialTokens
  ) /*throws*/ : TokenizedBatch;
}

/**
 * A tokenizer object from a custom dictionary.
 */
export class CustomTokenizerInner
  extends UniffiAbstractObject
  implements CustomTokenizerInnerInterface
{
  readonly [uniffiTypeNameSymbol] = 'CustomTokenizerInner';
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  /**
   * Creates a new custom tokenizer.
   */
  constructor(
    dictionary: string,
    padding: PaddingParams | undefined,
    truncation: TruncationParams | undefined
  ) /*throws*/ {
    super();
    const pointer = uniffiCaller.rustCallWithError(
      /*liftError:*/ FfiConverterTypeTokenizeError.lift.bind(
        FfiConverterTypeTokenizeError
      ),
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_vella_sdk_fn_constructor_customtokenizerinner_new(
          FfiConverterString.lower(dictionary),
          FfiConverterOptionalTypePaddingParams.lower(padding),
          FfiConverterOptionalTypeTruncationParams.lower(truncation),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    );
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] =
      uniffiTypeCustomTokenizerInnerObjectFactory.bless(pointer);
  }

  /**
   * Decode a given list of token ids, back to a string
   */
  public decode(
    tokens: Array</*u32*/ number>,
    specialTokens: SpecialTokens
  ): string | undefined {
    return FfiConverterOptionalString.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_vella_sdk_fn_method_customtokenizerinner_decode(
            uniffiTypeCustomTokenizerInnerObjectFactory.clonePointer(this),
            FfiConverterArrayUInt32.lower(tokens),
            FfiConverterTypeSpecialTokens.lower(specialTokens),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Tokenizes an input string and return a list of token IDs.
   */
  public getIds(
    input: string,
    specialTokens: SpecialTokens
  ): Array</*u32*/ number> /*throws*/ {
    return FfiConverterArrayUInt32.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeTokenizeError.lift.bind(
          FfiConverterTypeTokenizeError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_vella_sdk_fn_method_customtokenizerinner_get_ids(
            uniffiTypeCustomTokenizerInnerObjectFactory.clonePointer(this),
            FfiConverterString.lower(input),
            FfiConverterTypeSpecialTokens.lower(specialTokens),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Gets the configured pad token.
   */
  public getPadToken(): ReturnToken | undefined {
    return FfiConverterOptionalTypeReturnToken.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_vella_sdk_fn_method_customtokenizerinner_get_pad_token(
            uniffiTypeCustomTokenizerInnerObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Tokenizes an input string and returns a list of token strings.
   */
  public getTokens(
    input: string,
    specialTokens: SpecialTokens
  ): Array<string> /*throws*/ {
    return FfiConverterArrayString.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeTokenizeError.lift.bind(
          FfiConverterTypeTokenizeError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_vella_sdk_fn_method_customtokenizerinner_get_tokens(
            uniffiTypeCustomTokenizerInnerObjectFactory.clonePointer(this),
            FfiConverterString.lower(input),
            FfiConverterTypeSpecialTokens.lower(specialTokens),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Gets the string value of a given token ID.
   */
  public idToToken(id: /*u32*/ number): string | undefined {
    return FfiConverterOptionalString.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_vella_sdk_fn_method_customtokenizerinner_id_to_token(
            uniffiTypeCustomTokenizerInnerObjectFactory.clonePointer(this),
            FfiConverterUInt32.lower(id),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Gets the ID value of a given token.
   */
  public tokenToId(token: string): /*u32*/ number | undefined {
    return FfiConverterOptionalUInt32.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_vella_sdk_fn_method_customtokenizerinner_token_to_id(
            uniffiTypeCustomTokenizerInnerObjectFactory.clonePointer(this),
            FfiConverterString.lower(token),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Tokenizes an input string and returns a list of tokens.
   */
  public tokenize(
    input: string,
    specialTokens: SpecialTokens
  ): Array<Token> /*throws*/ {
    return FfiConverterArrayTypeToken.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeTokenizeError.lift.bind(
          FfiConverterTypeTokenizeError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_vella_sdk_fn_method_customtokenizerinner_tokenize(
            uniffiTypeCustomTokenizerInnerObjectFactory.clonePointer(this),
            FfiConverterString.lower(input),
            FfiConverterTypeSpecialTokens.lower(specialTokens),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Tokenizes a list of input strings and returns a list of token IDs.
   */
  public tokenizeBatch(
    input: Array<string>,
    specialTokens: SpecialTokens
  ): TokenizedBatch /*throws*/ {
    return FfiConverterTypeTokenizedBatch.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeTokenizeError.lift.bind(
          FfiConverterTypeTokenizeError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_vella_sdk_fn_method_customtokenizerinner_tokenize_batch(
            uniffiTypeCustomTokenizerInnerObjectFactory.clonePointer(this),
            FfiConverterArrayString.lower(input),
            FfiConverterTypeSpecialTokens.lower(specialTokens),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    const ptr = (this as any)[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer = uniffiTypeCustomTokenizerInnerObjectFactory.pointer(this);
      uniffiTypeCustomTokenizerInnerObjectFactory.freePointer(pointer);
      uniffiTypeCustomTokenizerInnerObjectFactory.unbless(ptr);
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is CustomTokenizerInner {
    return uniffiTypeCustomTokenizerInnerObjectFactory.isConcreteType(obj);
  }
}

const uniffiTypeCustomTokenizerInnerObjectFactory: UniffiObjectFactory<CustomTokenizerInnerInterface> =
  {
    create(pointer: UnsafeMutableRawPointer): CustomTokenizerInnerInterface {
      const instance = Object.create(CustomTokenizerInner.prototype);
      instance[pointerLiteralSymbol] = pointer;
      instance[destructorGuardSymbol] = this.bless(pointer);
      instance[uniffiTypeNameSymbol] = 'CustomTokenizerInner';
      return instance;
    },

    bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
      return uniffiCaller.rustCall(
        /*caller:*/ (status) =>
          nativeModule().ubrn_uniffi_internal_fn_method_customtokenizerinner_ffi__bless_pointer(
            p,
            status
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    unbless(ptr: UniffiRustArcPtr) {
      ptr.markDestroyed();
    },

    pointer(obj: CustomTokenizerInnerInterface): UnsafeMutableRawPointer {
      if ((obj as any)[destructorGuardSymbol] === undefined) {
        throw new UniffiInternalError.UnexpectedNullPointer();
      }
      return (obj as any)[pointerLiteralSymbol];
    },

    clonePointer(obj: CustomTokenizerInnerInterface): UnsafeMutableRawPointer {
      const pointer = this.pointer(obj);
      return uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_vella_sdk_fn_clone_customtokenizerinner(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    freePointer(pointer: UnsafeMutableRawPointer): void {
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_vella_sdk_fn_free_customtokenizerinner(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    isConcreteType(obj: any): obj is CustomTokenizerInnerInterface {
      return (
        obj[destructorGuardSymbol] &&
        obj[uniffiTypeNameSymbol] === 'CustomTokenizerInner'
      );
    },
  };
// FfiConverter for CustomTokenizerInnerInterface
const FfiConverterTypeCustomTokenizerInner = new FfiConverterObject(
  uniffiTypeCustomTokenizerInnerObjectFactory
);

// FfiConverter for /*i64*/bigint | undefined
const FfiConverterOptionalInt64 = new FfiConverterOptional(FfiConverterInt64);

// FfiConverter for PaddingParams | undefined
const FfiConverterOptionalTypePaddingParams = new FfiConverterOptional(
  FfiConverterTypePaddingParams
);

// FfiConverter for ReturnToken | undefined
const FfiConverterOptionalTypeReturnToken = new FfiConverterOptional(
  FfiConverterTypeReturnToken
);

// FfiConverter for TruncationParams | undefined
const FfiConverterOptionalTypeTruncationParams = new FfiConverterOptional(
  FfiConverterTypeTruncationParams
);

// FfiConverter for UnsubscribeEmail | undefined
const FfiConverterOptionalTypeUnsubscribeEmail = new FfiConverterOptional(
  FfiConverterTypeUnsubscribeEmail
);

// FfiConverter for UnsubscribePost | undefined
const FfiConverterOptionalTypeUnsubscribePost = new FfiConverterOptional(
  FfiConverterTypeUnsubscribePost
);

// FfiConverter for string | undefined
const FfiConverterOptionalString = new FfiConverterOptional(FfiConverterString);

// FfiConverter for /*u32*/number | undefined
const FfiConverterOptionalUInt32 = new FfiConverterOptional(FfiConverterUInt32);

// FfiConverter for Array<BatchSection>
const FfiConverterArrayTypeBatchSection = new FfiConverterArray(
  FfiConverterTypeBatchSection
);

// FfiConverter for Array<CalendarEvent>
const FfiConverterArrayTypeCalendarEvent = new FfiConverterArray(
  FfiConverterTypeCalendarEvent
);

// FfiConverter for Array<EmailAddress>
const FfiConverterArrayTypeEmailAddress = new FfiConverterArray(
  FfiConverterTypeEmailAddress
);

// FfiConverter for Array<EmailText>
const FfiConverterArrayTypeEmailText = new FfiConverterArray(
  FfiConverterTypeEmailText
);

// FfiConverter for Array<GmailErrorItem>
const FfiConverterArrayTypeGmailErrorItem = new FfiConverterArray(
  FfiConverterTypeGmailErrorItem
);

// FfiConverter for Array<Header>
const FfiConverterArrayTypeHeader = new FfiConverterArray(
  FfiConverterTypeHeader
);

// FfiConverter for Array<MicrodataItem>
const FfiConverterArrayTypeMicrodataItem = new FfiConverterArray(
  FfiConverterTypeMicrodataItem
);

// FfiConverter for Array<Token>
const FfiConverterArrayTypeToken = new FfiConverterArray(FfiConverterTypeToken);

// FfiConverter for Array<string>
const FfiConverterArrayString = new FfiConverterArray(FfiConverterString);

// FfiConverter for Array</*u32*/number>
const FfiConverterArrayUInt32 = new FfiConverterArray(FfiConverterUInt32);

// FfiConverter for CalendarEventStatus | undefined
const FfiConverterOptionalTypeCalendarEventStatus = new FfiConverterOptional(
  FfiConverterTypeCalendarEventStatus
);

// FfiConverter for Array<Array</*u32*/number>>
const FfiConverterArrayArrayUInt32 = new FfiConverterArray(
  FfiConverterArrayUInt32
);

/**
 * This should be called before anything else.
 *
 * It is likely that this is being done for you by the library's `index.ts`.
 *
 * It checks versions of uniffi between when the Rust scaffolding was generated
 * and when the bindings were generated.
 *
 * It also initializes the machinery to enable Rust to talk back to Javascript.
 */
function uniffiEnsureInitialized() {
  // Get the bindings contract version from our ComponentInterface
  const bindingsContractVersion = 29;
  // Get the scaffolding contract version by calling the into the dylib
  const scaffoldingContractVersion =
    nativeModule().ubrn_ffi_vella_sdk_uniffi_contract_version();
  if (bindingsContractVersion !== scaffoldingContractVersion) {
    throw new UniffiInternalError.ContractVersionMismatch(
      scaffoldingContractVersion,
      bindingsContractVersion
    );
  }
  if (
    nativeModule().ubrn_uniffi_vella_sdk_checksum_func_escape_text() !== 30725
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_vella_sdk_checksum_func_escape_text'
    );
  }
  if (
    nativeModule().ubrn_uniffi_vella_sdk_checksum_func_parse_batch_response() !==
    14624
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_vella_sdk_checksum_func_parse_batch_response'
    );
  }
  if (
    nativeModule().ubrn_uniffi_vella_sdk_checksum_func_parse_email() !== 23062
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_vella_sdk_checksum_func_parse_email'
    );
  }
  if (
    nativeModule().ubrn_uniffi_vella_sdk_checksum_func_parse_visible_html() !==
    14978
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_vella_sdk_checksum_func_parse_visible_html'
    );
  }
  if (
    nativeModule().ubrn_uniffi_vella_sdk_checksum_func_parse_visible_text() !==
    17560
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_vella_sdk_checksum_func_parse_visible_text'
    );
  }
  if (
    nativeModule().ubrn_uniffi_vella_sdk_checksum_method_customtokenizerinner_decode() !==
    41492
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_vella_sdk_checksum_method_customtokenizerinner_decode'
    );
  }
  if (
    nativeModule().ubrn_uniffi_vella_sdk_checksum_method_customtokenizerinner_get_ids() !==
    28986
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_vella_sdk_checksum_method_customtokenizerinner_get_ids'
    );
  }
  if (
    nativeModule().ubrn_uniffi_vella_sdk_checksum_method_customtokenizerinner_get_pad_token() !==
    39869
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_vella_sdk_checksum_method_customtokenizerinner_get_pad_token'
    );
  }
  if (
    nativeModule().ubrn_uniffi_vella_sdk_checksum_method_customtokenizerinner_get_tokens() !==
    27258
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_vella_sdk_checksum_method_customtokenizerinner_get_tokens'
    );
  }
  if (
    nativeModule().ubrn_uniffi_vella_sdk_checksum_method_customtokenizerinner_id_to_token() !==
    31500
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_vella_sdk_checksum_method_customtokenizerinner_id_to_token'
    );
  }
  if (
    nativeModule().ubrn_uniffi_vella_sdk_checksum_method_customtokenizerinner_token_to_id() !==
    55982
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_vella_sdk_checksum_method_customtokenizerinner_token_to_id'
    );
  }
  if (
    nativeModule().ubrn_uniffi_vella_sdk_checksum_method_customtokenizerinner_tokenize() !==
    39025
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_vella_sdk_checksum_method_customtokenizerinner_tokenize'
    );
  }
  if (
    nativeModule().ubrn_uniffi_vella_sdk_checksum_method_customtokenizerinner_tokenize_batch() !==
    50675
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_vella_sdk_checksum_method_customtokenizerinner_tokenize_batch'
    );
  }
  if (
    nativeModule().ubrn_uniffi_vella_sdk_checksum_constructor_customtokenizerinner_new() !==
    38265
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_vella_sdk_checksum_constructor_customtokenizerinner_new'
    );
  }
}

export default Object.freeze({
  initialize: uniffiEnsureInitialized,
  converters: {
    FfiConverterTypeBatchResponse,
    FfiConverterTypeBatchSection,
    FfiConverterTypeCalendarEvent,
    FfiConverterTypeCalendarEventStatus,
    FfiConverterTypeCustomTokenizerInner,
    FfiConverterTypeEmail,
    FfiConverterTypeEmailAddress,
    FfiConverterTypeEmailAddressWithText,
    FfiConverterTypeEmailText,
    FfiConverterTypeGmailError,
    FfiConverterTypeGmailErrorItem,
    FfiConverterTypeGmailMessage,
    FfiConverterTypeHeader,
    FfiConverterTypeMicrodataItem,
    FfiConverterTypePaddingDirection,
    FfiConverterTypePaddingParams,
    FfiConverterTypePaddingStrategy,
    FfiConverterTypeReturnToken,
    FfiConverterTypeSpecialTokens,
    FfiConverterTypeToken,
    FfiConverterTypeTokenizedBatch,
    FfiConverterTypeTruncationDirection,
    FfiConverterTypeTruncationParams,
    FfiConverterTypeTruncationStrategy,
    FfiConverterTypeUnsubscribe,
    FfiConverterTypeUnsubscribeEmail,
    FfiConverterTypeUnsubscribePost,
  },
});
