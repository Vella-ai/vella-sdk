// This file was autogenerated by some hot garbage in the `uniffi-bindgen-react-native` crate.
// Trust me, you don't want to mess with it!
import nativeModule, {
  type UniffiRustFutureContinuationCallback,
  type UniffiForeignFuture,
  type UniffiForeignFutureStructU8,
  type UniffiForeignFutureCompleteU8,
  type UniffiForeignFutureStructI8,
  type UniffiForeignFutureCompleteI8,
  type UniffiForeignFutureStructU16,
  type UniffiForeignFutureCompleteU16,
  type UniffiForeignFutureStructI16,
  type UniffiForeignFutureCompleteI16,
  type UniffiForeignFutureStructU32,
  type UniffiForeignFutureCompleteU32,
  type UniffiForeignFutureStructI32,
  type UniffiForeignFutureCompleteI32,
  type UniffiForeignFutureStructU64,
  type UniffiForeignFutureCompleteU64,
  type UniffiForeignFutureStructI64,
  type UniffiForeignFutureCompleteI64,
  type UniffiForeignFutureStructF32,
  type UniffiForeignFutureCompleteF32,
  type UniffiForeignFutureStructF64,
  type UniffiForeignFutureCompleteF64,
  type UniffiForeignFutureStructPointer,
  type UniffiForeignFutureCompletePointer,
  type UniffiForeignFutureStructRustBuffer,
  type UniffiForeignFutureCompleteRustBuffer,
  type UniffiForeignFutureStructVoid,
  type UniffiForeignFutureCompleteVoid,
} from './vella_sdk-ffi';
import {
  type UniffiByteArray,
  AbstractFfiConverterByteArray,
  FfiConverterArray,
  FfiConverterBool,
  FfiConverterInt32,
  FfiConverterInt64,
  FfiConverterOptional,
  FfiConverterUInt32,
  RustBuffer,
  UniffiEnum,
  UniffiError,
  UniffiInternalError,
  UniffiRustCaller,
  uniffiCreateFfiConverterString,
  uniffiCreateRecord,
  uniffiTypeNameSymbol,
  variantOrdinalSymbol,
} from 'uniffi-bindgen-react-native';

// Get converters from the other files, if any.
const uniffiCaller = new UniffiRustCaller();

const uniffiIsDebug =
  // @ts-ignore -- The process global might not be defined
  typeof process !== 'object' ||
  // @ts-ignore -- The process global might not be defined
  process?.env?.NODE_ENV !== 'production' ||
  false;
// Public interface members begin here.

export function escapeText(text: string): string {
  return FfiConverterString.lift(
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_vella_sdk_fn_func_escape_text(
          FfiConverterString.lower(text),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    )
  );
}
export function parseBatchResponse(body: string): Array<BatchSection> {
  return FfiConverterArrayTypeBatchSection.lift(
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_vella_sdk_fn_func_parse_batch_response(
          FfiConverterString.lower(body),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    )
  );
}
export function parseEmail(raw: string): Email /*throws*/ {
  return FfiConverterTypeEmail.lift(
    uniffiCaller.rustCallWithError(
      /*liftError:*/ FfiConverterTypeParserError.lift.bind(
        FfiConverterTypeParserError
      ),
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_vella_sdk_fn_func_parse_email(
          FfiConverterString.lower(raw),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    )
  );
}
export function parseVisibleHtml(body: string): string | undefined {
  return FfiConverterOptionalString.lift(
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_vella_sdk_fn_func_parse_visible_html(
          FfiConverterString.lower(body),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    )
  );
}
export function parseVisibleText(body: string): string | undefined {
  return FfiConverterOptionalString.lift(
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_vella_sdk_fn_func_parse_visible_text(
          FfiConverterString.lower(body),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    )
  );
}

export type BatchSection = {
  batchName: string;
  response: BatchResponse;
};

/**
 * Generated factory for {@link BatchSection} record objects.
 */
export const BatchSection = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<BatchSection, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link BatchSection}, with defaults specified
     * in Rust, in the {@link vella_sdk} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link BatchSection}, with defaults specified
     * in Rust, in the {@link vella_sdk} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link vella_sdk} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<BatchSection>,
  });
})();

const FfiConverterTypeBatchSection = (() => {
  type TypeName = BatchSection;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        batchName: FfiConverterString.read(from),
        response: FfiConverterTypeBatchResponse.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.batchName, into);
      FfiConverterTypeBatchResponse.write(value.response, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.batchName) +
        FfiConverterTypeBatchResponse.allocationSize(value.response)
      );
    }
  }
  return new FFIConverter();
})();

export type Email = {
  from: EmailAddressWithText;
  fromAddresses: Array<EmailAddress>;
  to: EmailAddressWithText;
  toAddresses: Array<EmailAddress>;
  ccAddresses: Array<EmailAddress>;
  bccAddresses: Array<EmailAddress>;
  subject: string | undefined;
  /**
   * Unix epoch in seconds
   */
  date: /*i64*/ bigint | undefined;
  contentId: string | undefined;
  messageId: string | undefined;
  threadName: string | undefined;
  mimeVersion: string | undefined;
  headers: Array<Header>;
  textBodies: Array<EmailText>;
  htmlBodies: Array<EmailText>;
};

/**
 * Generated factory for {@link Email} record objects.
 */
export const Email = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<Email, ReturnType<typeof defaults>>(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link Email}, with defaults specified
     * in Rust, in the {@link vella_sdk} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link Email}, with defaults specified
     * in Rust, in the {@link vella_sdk} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link vella_sdk} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<Email>,
  });
})();

const FfiConverterTypeEmail = (() => {
  type TypeName = Email;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        from: FfiConverterTypeEmailAddressWithText.read(from),
        fromAddresses: FfiConverterArrayTypeEmailAddress.read(from),
        to: FfiConverterTypeEmailAddressWithText.read(from),
        toAddresses: FfiConverterArrayTypeEmailAddress.read(from),
        ccAddresses: FfiConverterArrayTypeEmailAddress.read(from),
        bccAddresses: FfiConverterArrayTypeEmailAddress.read(from),
        subject: FfiConverterOptionalString.read(from),
        date: FfiConverterOptionalInt64.read(from),
        contentId: FfiConverterOptionalString.read(from),
        messageId: FfiConverterOptionalString.read(from),
        threadName: FfiConverterOptionalString.read(from),
        mimeVersion: FfiConverterOptionalString.read(from),
        headers: FfiConverterArrayTypeHeader.read(from),
        textBodies: FfiConverterArrayTypeEmailText.read(from),
        htmlBodies: FfiConverterArrayTypeEmailText.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterTypeEmailAddressWithText.write(value.from, into);
      FfiConverterArrayTypeEmailAddress.write(value.fromAddresses, into);
      FfiConverterTypeEmailAddressWithText.write(value.to, into);
      FfiConverterArrayTypeEmailAddress.write(value.toAddresses, into);
      FfiConverterArrayTypeEmailAddress.write(value.ccAddresses, into);
      FfiConverterArrayTypeEmailAddress.write(value.bccAddresses, into);
      FfiConverterOptionalString.write(value.subject, into);
      FfiConverterOptionalInt64.write(value.date, into);
      FfiConverterOptionalString.write(value.contentId, into);
      FfiConverterOptionalString.write(value.messageId, into);
      FfiConverterOptionalString.write(value.threadName, into);
      FfiConverterOptionalString.write(value.mimeVersion, into);
      FfiConverterArrayTypeHeader.write(value.headers, into);
      FfiConverterArrayTypeEmailText.write(value.textBodies, into);
      FfiConverterArrayTypeEmailText.write(value.htmlBodies, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterTypeEmailAddressWithText.allocationSize(value.from) +
        FfiConverterArrayTypeEmailAddress.allocationSize(value.fromAddresses) +
        FfiConverterTypeEmailAddressWithText.allocationSize(value.to) +
        FfiConverterArrayTypeEmailAddress.allocationSize(value.toAddresses) +
        FfiConverterArrayTypeEmailAddress.allocationSize(value.ccAddresses) +
        FfiConverterArrayTypeEmailAddress.allocationSize(value.bccAddresses) +
        FfiConverterOptionalString.allocationSize(value.subject) +
        FfiConverterOptionalInt64.allocationSize(value.date) +
        FfiConverterOptionalString.allocationSize(value.contentId) +
        FfiConverterOptionalString.allocationSize(value.messageId) +
        FfiConverterOptionalString.allocationSize(value.threadName) +
        FfiConverterOptionalString.allocationSize(value.mimeVersion) +
        FfiConverterArrayTypeHeader.allocationSize(value.headers) +
        FfiConverterArrayTypeEmailText.allocationSize(value.textBodies) +
        FfiConverterArrayTypeEmailText.allocationSize(value.htmlBodies)
      );
    }
  }
  return new FFIConverter();
})();

export type EmailAddress = {
  name: string | undefined;
  address: string;
};

/**
 * Generated factory for {@link EmailAddress} record objects.
 */
export const EmailAddress = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<EmailAddress, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link EmailAddress}, with defaults specified
     * in Rust, in the {@link vella_sdk} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link EmailAddress}, with defaults specified
     * in Rust, in the {@link vella_sdk} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link vella_sdk} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<EmailAddress>,
  });
})();

const FfiConverterTypeEmailAddress = (() => {
  type TypeName = EmailAddress;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        name: FfiConverterOptionalString.read(from),
        address: FfiConverterString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterOptionalString.write(value.name, into);
      FfiConverterString.write(value.address, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterOptionalString.allocationSize(value.name) +
        FfiConverterString.allocationSize(value.address)
      );
    }
  }
  return new FFIConverter();
})();

export type EmailAddressWithText = {
  name: string | undefined;
  text: string;
  address: string;
};

/**
 * Generated factory for {@link EmailAddressWithText} record objects.
 */
export const EmailAddressWithText = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<
      EmailAddressWithText,
      ReturnType<typeof defaults>
    >(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link EmailAddressWithText}, with defaults specified
     * in Rust, in the {@link vella_sdk} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link EmailAddressWithText}, with defaults specified
     * in Rust, in the {@link vella_sdk} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link vella_sdk} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<EmailAddressWithText>,
  });
})();

const FfiConverterTypeEmailAddressWithText = (() => {
  type TypeName = EmailAddressWithText;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        name: FfiConverterOptionalString.read(from),
        text: FfiConverterString.read(from),
        address: FfiConverterString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterOptionalString.write(value.name, into);
      FfiConverterString.write(value.text, into);
      FfiConverterString.write(value.address, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterOptionalString.allocationSize(value.name) +
        FfiConverterString.allocationSize(value.text) +
        FfiConverterString.allocationSize(value.address)
      );
    }
  }
  return new FFIConverter();
})();

export type EmailText = {
  text: string;
  visible: string | undefined;
};

/**
 * Generated factory for {@link EmailText} record objects.
 */
export const EmailText = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<EmailText, ReturnType<typeof defaults>>(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link EmailText}, with defaults specified
     * in Rust, in the {@link vella_sdk} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link EmailText}, with defaults specified
     * in Rust, in the {@link vella_sdk} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link vella_sdk} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<EmailText>,
  });
})();

const FfiConverterTypeEmailText = (() => {
  type TypeName = EmailText;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        text: FfiConverterString.read(from),
        visible: FfiConverterOptionalString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.text, into);
      FfiConverterOptionalString.write(value.visible, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.text) +
        FfiConverterOptionalString.allocationSize(value.visible)
      );
    }
  }
  return new FFIConverter();
})();

export type GmailError = {
  code: /*u32*/ number;
  message: string;
  status: string;
  errors: Array<GmailErrorItem>;
};

/**
 * Generated factory for {@link GmailError} record objects.
 */
export const GmailError = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<GmailError, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link GmailError}, with defaults specified
     * in Rust, in the {@link vella_sdk} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link GmailError}, with defaults specified
     * in Rust, in the {@link vella_sdk} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link vella_sdk} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<GmailError>,
  });
})();

const FfiConverterTypeGmailError = (() => {
  type TypeName = GmailError;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        code: FfiConverterUInt32.read(from),
        message: FfiConverterString.read(from),
        status: FfiConverterString.read(from),
        errors: FfiConverterArrayTypeGmailErrorItem.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterUInt32.write(value.code, into);
      FfiConverterString.write(value.message, into);
      FfiConverterString.write(value.status, into);
      FfiConverterArrayTypeGmailErrorItem.write(value.errors, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterUInt32.allocationSize(value.code) +
        FfiConverterString.allocationSize(value.message) +
        FfiConverterString.allocationSize(value.status) +
        FfiConverterArrayTypeGmailErrorItem.allocationSize(value.errors)
      );
    }
  }
  return new FFIConverter();
})();

export type GmailErrorItem = {
  message: string;
  domain: string;
  reason: string;
};

/**
 * Generated factory for {@link GmailErrorItem} record objects.
 */
export const GmailErrorItem = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<GmailErrorItem, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link GmailErrorItem}, with defaults specified
     * in Rust, in the {@link vella_sdk} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link GmailErrorItem}, with defaults specified
     * in Rust, in the {@link vella_sdk} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link vella_sdk} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<GmailErrorItem>,
  });
})();

const FfiConverterTypeGmailErrorItem = (() => {
  type TypeName = GmailErrorItem;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        message: FfiConverterString.read(from),
        domain: FfiConverterString.read(from),
        reason: FfiConverterString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.message, into);
      FfiConverterString.write(value.domain, into);
      FfiConverterString.write(value.reason, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.message) +
        FfiConverterString.allocationSize(value.domain) +
        FfiConverterString.allocationSize(value.reason)
      );
    }
  }
  return new FFIConverter();
})();

export type GmailMessage = {
  id: string;
  threadId: string;
  labelIds: Array<string>;
  snippet: EmailText;
  sizeEstimate: /*u32*/ number;
  data: Email;
  historyId: string;
  internalDate: string;
};

/**
 * Generated factory for {@link GmailMessage} record objects.
 */
export const GmailMessage = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<GmailMessage, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link GmailMessage}, with defaults specified
     * in Rust, in the {@link vella_sdk} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link GmailMessage}, with defaults specified
     * in Rust, in the {@link vella_sdk} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link vella_sdk} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<GmailMessage>,
  });
})();

const FfiConverterTypeGmailMessage = (() => {
  type TypeName = GmailMessage;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        id: FfiConverterString.read(from),
        threadId: FfiConverterString.read(from),
        labelIds: FfiConverterArrayString.read(from),
        snippet: FfiConverterTypeEmailText.read(from),
        sizeEstimate: FfiConverterUInt32.read(from),
        data: FfiConverterTypeEmail.read(from),
        historyId: FfiConverterString.read(from),
        internalDate: FfiConverterString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.id, into);
      FfiConverterString.write(value.threadId, into);
      FfiConverterArrayString.write(value.labelIds, into);
      FfiConverterTypeEmailText.write(value.snippet, into);
      FfiConverterUInt32.write(value.sizeEstimate, into);
      FfiConverterTypeEmail.write(value.data, into);
      FfiConverterString.write(value.historyId, into);
      FfiConverterString.write(value.internalDate, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.id) +
        FfiConverterString.allocationSize(value.threadId) +
        FfiConverterArrayString.allocationSize(value.labelIds) +
        FfiConverterTypeEmailText.allocationSize(value.snippet) +
        FfiConverterUInt32.allocationSize(value.sizeEstimate) +
        FfiConverterTypeEmail.allocationSize(value.data) +
        FfiConverterString.allocationSize(value.historyId) +
        FfiConverterString.allocationSize(value.internalDate)
      );
    }
  }
  return new FFIConverter();
})();

export type Header = {
  name: string;
  value: string;
};

/**
 * Generated factory for {@link Header} record objects.
 */
export const Header = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<Header, ReturnType<typeof defaults>>(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link Header}, with defaults specified
     * in Rust, in the {@link vella_sdk} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link Header}, with defaults specified
     * in Rust, in the {@link vella_sdk} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link vella_sdk} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<Header>,
  });
})();

const FfiConverterTypeHeader = (() => {
  type TypeName = Header;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        name: FfiConverterString.read(from),
        value: FfiConverterString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.name, into);
      FfiConverterString.write(value.value, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.name) +
        FfiConverterString.allocationSize(value.value)
      );
    }
  }
  return new FFIConverter();
})();

const stringConverter = {
  stringToBytes: (s: string) =>
    uniffiCaller.rustCall((status) =>
      nativeModule().ubrn_uniffi_internal_fn_func_ffi__string_to_arraybuffer(
        s,
        status
      )
    ),
  bytesToString: (ab: UniffiByteArray) =>
    uniffiCaller.rustCall((status) =>
      nativeModule().ubrn_uniffi_internal_fn_func_ffi__arraybuffer_to_string(
        ab,
        status
      )
    ),
  stringByteLength: (s: string) =>
    uniffiCaller.rustCall((status) =>
      nativeModule().ubrn_uniffi_internal_fn_func_ffi__string_to_byte_length(
        s,
        status
      )
    ),
};
const FfiConverterString = uniffiCreateFfiConverterString(stringConverter);

// Enum: BatchResponse
export enum BatchResponse_Tags {
  Success = 'Success',
  Error = 'Error',
}
export const BatchResponse = (() => {
  type Success__interface = {
    tag: BatchResponse_Tags.Success;
    inner: Readonly<[GmailMessage]>;
  };

  class Success_ extends UniffiEnum implements Success__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'BatchResponse';
    readonly tag = BatchResponse_Tags.Success;
    readonly inner: Readonly<[GmailMessage]>;
    constructor(v0: GmailMessage) {
      super('BatchResponse', 'Success');
      this.inner = Object.freeze([v0]);
    }

    static new(v0: GmailMessage): Success_ {
      return new Success_(v0);
    }

    static instanceOf(obj: any): obj is Success_ {
      return obj.tag === BatchResponse_Tags.Success;
    }
  }

  type Error__interface = {
    tag: BatchResponse_Tags.Error;
    inner: Readonly<[GmailError]>;
  };

  class Error_ extends UniffiEnum implements Error__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'BatchResponse';
    readonly tag = BatchResponse_Tags.Error;
    readonly inner: Readonly<[GmailError]>;
    constructor(v0: GmailError) {
      super('BatchResponse', 'Error');
      this.inner = Object.freeze([v0]);
    }

    static new(v0: GmailError): Error_ {
      return new Error_(v0);
    }

    static instanceOf(obj: any): obj is Error_ {
      return obj.tag === BatchResponse_Tags.Error;
    }
  }

  function instanceOf(obj: any): obj is BatchResponse {
    return obj[uniffiTypeNameSymbol] === 'BatchResponse';
  }

  return Object.freeze({
    instanceOf,
    Success: Success_,
    Error: Error_,
  });
})();

export type BatchResponse = InstanceType<
  (typeof BatchResponse)[keyof Omit<typeof BatchResponse, 'instanceOf'>]
>;

// FfiConverter for enum BatchResponse
const FfiConverterTypeBatchResponse = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = BatchResponse;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new BatchResponse.Success(
            FfiConverterTypeGmailMessage.read(from)
          );
        case 2:
          return new BatchResponse.Error(FfiConverterTypeGmailError.read(from));
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case BatchResponse_Tags.Success: {
          ordinalConverter.write(1, into);
          const inner = value.inner;
          FfiConverterTypeGmailMessage.write(inner[0], into);
          return;
        }
        case BatchResponse_Tags.Error: {
          ordinalConverter.write(2, into);
          const inner = value.inner;
          FfiConverterTypeGmailError.write(inner[0], into);
          return;
        }
        default:
          // Throwing from here means that BatchResponse_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case BatchResponse_Tags.Success: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(1);
          size += FfiConverterTypeGmailMessage.allocationSize(inner[0]);
          return size;
        }
        case BatchResponse_Tags.Error: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(2);
          size += FfiConverterTypeGmailError.allocationSize(inner[0]);
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

// Error type: ParserError

// Enum: ParserError
export enum ParserError_Tags {
  Base64DecodeFailed = 'Base64DecodeFailed',
  NonUtfInput = 'NonUtfInput',
  EmptyInput = 'EmptyInput',
  EmailParseFailed = 'EmailParseFailed',
  NoFromHeader = 'NoFromHeader',
  NoToHeader = 'NoToHeader',
}
export const ParserError = (() => {
  type Base64DecodeFailed__interface = {
    tag: ParserError_Tags.Base64DecodeFailed;
  };

  class Base64DecodeFailed_
    extends UniffiError
    implements Base64DecodeFailed__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'ParserError';
    readonly tag = ParserError_Tags.Base64DecodeFailed;
    constructor() {
      super('ParserError', 'Base64DecodeFailed');
    }

    static new(): Base64DecodeFailed_ {
      return new Base64DecodeFailed_();
    }

    static instanceOf(obj: any): obj is Base64DecodeFailed_ {
      return obj.tag === ParserError_Tags.Base64DecodeFailed;
    }

    static hasInner(obj: any): obj is Base64DecodeFailed_ {
      return false;
    }
  }

  type NonUtfInput__interface = {
    tag: ParserError_Tags.NonUtfInput;
  };

  class NonUtfInput_ extends UniffiError implements NonUtfInput__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'ParserError';
    readonly tag = ParserError_Tags.NonUtfInput;
    constructor() {
      super('ParserError', 'NonUtfInput');
    }

    static new(): NonUtfInput_ {
      return new NonUtfInput_();
    }

    static instanceOf(obj: any): obj is NonUtfInput_ {
      return obj.tag === ParserError_Tags.NonUtfInput;
    }

    static hasInner(obj: any): obj is NonUtfInput_ {
      return false;
    }
  }

  type EmptyInput__interface = {
    tag: ParserError_Tags.EmptyInput;
  };

  class EmptyInput_ extends UniffiError implements EmptyInput__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'ParserError';
    readonly tag = ParserError_Tags.EmptyInput;
    constructor() {
      super('ParserError', 'EmptyInput');
    }

    static new(): EmptyInput_ {
      return new EmptyInput_();
    }

    static instanceOf(obj: any): obj is EmptyInput_ {
      return obj.tag === ParserError_Tags.EmptyInput;
    }

    static hasInner(obj: any): obj is EmptyInput_ {
      return false;
    }
  }

  type EmailParseFailed__interface = {
    tag: ParserError_Tags.EmailParseFailed;
  };

  class EmailParseFailed_
    extends UniffiError
    implements EmailParseFailed__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'ParserError';
    readonly tag = ParserError_Tags.EmailParseFailed;
    constructor() {
      super('ParserError', 'EmailParseFailed');
    }

    static new(): EmailParseFailed_ {
      return new EmailParseFailed_();
    }

    static instanceOf(obj: any): obj is EmailParseFailed_ {
      return obj.tag === ParserError_Tags.EmailParseFailed;
    }

    static hasInner(obj: any): obj is EmailParseFailed_ {
      return false;
    }
  }

  type NoFromHeader__interface = {
    tag: ParserError_Tags.NoFromHeader;
  };

  class NoFromHeader_ extends UniffiError implements NoFromHeader__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'ParserError';
    readonly tag = ParserError_Tags.NoFromHeader;
    constructor() {
      super('ParserError', 'NoFromHeader');
    }

    static new(): NoFromHeader_ {
      return new NoFromHeader_();
    }

    static instanceOf(obj: any): obj is NoFromHeader_ {
      return obj.tag === ParserError_Tags.NoFromHeader;
    }

    static hasInner(obj: any): obj is NoFromHeader_ {
      return false;
    }
  }

  type NoToHeader__interface = {
    tag: ParserError_Tags.NoToHeader;
  };

  class NoToHeader_ extends UniffiError implements NoToHeader__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'ParserError';
    readonly tag = ParserError_Tags.NoToHeader;
    constructor() {
      super('ParserError', 'NoToHeader');
    }

    static new(): NoToHeader_ {
      return new NoToHeader_();
    }

    static instanceOf(obj: any): obj is NoToHeader_ {
      return obj.tag === ParserError_Tags.NoToHeader;
    }

    static hasInner(obj: any): obj is NoToHeader_ {
      return false;
    }
  }

  function instanceOf(obj: any): obj is ParserError {
    return obj[uniffiTypeNameSymbol] === 'ParserError';
  }

  return Object.freeze({
    instanceOf,
    Base64DecodeFailed: Base64DecodeFailed_,
    NonUtfInput: NonUtfInput_,
    EmptyInput: EmptyInput_,
    EmailParseFailed: EmailParseFailed_,
    NoFromHeader: NoFromHeader_,
    NoToHeader: NoToHeader_,
  });
})();

export type ParserError = InstanceType<
  (typeof ParserError)[keyof Omit<typeof ParserError, 'instanceOf'>]
>;

// FfiConverter for enum ParserError
const FfiConverterTypeParserError = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = ParserError;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new ParserError.Base64DecodeFailed();
        case 2:
          return new ParserError.NonUtfInput();
        case 3:
          return new ParserError.EmptyInput();
        case 4:
          return new ParserError.EmailParseFailed();
        case 5:
          return new ParserError.NoFromHeader();
        case 6:
          return new ParserError.NoToHeader();
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case ParserError_Tags.Base64DecodeFailed: {
          ordinalConverter.write(1, into);
          return;
        }
        case ParserError_Tags.NonUtfInput: {
          ordinalConverter.write(2, into);
          return;
        }
        case ParserError_Tags.EmptyInput: {
          ordinalConverter.write(3, into);
          return;
        }
        case ParserError_Tags.EmailParseFailed: {
          ordinalConverter.write(4, into);
          return;
        }
        case ParserError_Tags.NoFromHeader: {
          ordinalConverter.write(5, into);
          return;
        }
        case ParserError_Tags.NoToHeader: {
          ordinalConverter.write(6, into);
          return;
        }
        default:
          // Throwing from here means that ParserError_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case ParserError_Tags.Base64DecodeFailed: {
          return ordinalConverter.allocationSize(1);
        }
        case ParserError_Tags.NonUtfInput: {
          return ordinalConverter.allocationSize(2);
        }
        case ParserError_Tags.EmptyInput: {
          return ordinalConverter.allocationSize(3);
        }
        case ParserError_Tags.EmailParseFailed: {
          return ordinalConverter.allocationSize(4);
        }
        case ParserError_Tags.NoFromHeader: {
          return ordinalConverter.allocationSize(5);
        }
        case ParserError_Tags.NoToHeader: {
          return ordinalConverter.allocationSize(6);
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

// FfiConverter for /*i64*/bigint | undefined
const FfiConverterOptionalInt64 = new FfiConverterOptional(FfiConverterInt64);

// FfiConverter for string | undefined
const FfiConverterOptionalString = new FfiConverterOptional(FfiConverterString);

// FfiConverter for Array<BatchSection>
const FfiConverterArrayTypeBatchSection = new FfiConverterArray(
  FfiConverterTypeBatchSection
);

// FfiConverter for Array<EmailAddress>
const FfiConverterArrayTypeEmailAddress = new FfiConverterArray(
  FfiConverterTypeEmailAddress
);

// FfiConverter for Array<EmailText>
const FfiConverterArrayTypeEmailText = new FfiConverterArray(
  FfiConverterTypeEmailText
);

// FfiConverter for Array<GmailErrorItem>
const FfiConverterArrayTypeGmailErrorItem = new FfiConverterArray(
  FfiConverterTypeGmailErrorItem
);

// FfiConverter for Array<Header>
const FfiConverterArrayTypeHeader = new FfiConverterArray(
  FfiConverterTypeHeader
);

// FfiConverter for Array<string>
const FfiConverterArrayString = new FfiConverterArray(FfiConverterString);

/**
 * This should be called before anything else.
 *
 * It is likely that this is being done for you by the library's `index.ts`.
 *
 * It checks versions of uniffi between when the Rust scaffolding was generated
 * and when the bindings were generated.
 *
 * It also initializes the machinery to enable Rust to talk back to Javascript.
 */
function uniffiEnsureInitialized() {
  // Get the bindings contract version from our ComponentInterface
  const bindingsContractVersion = 29;
  // Get the scaffolding contract version by calling the into the dylib
  const scaffoldingContractVersion =
    nativeModule().ubrn_ffi_vella_sdk_uniffi_contract_version();
  if (bindingsContractVersion !== scaffoldingContractVersion) {
    throw new UniffiInternalError.ContractVersionMismatch(
      scaffoldingContractVersion,
      bindingsContractVersion
    );
  }
  if (
    nativeModule().ubrn_uniffi_vella_sdk_checksum_func_escape_text() !== 30725
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_vella_sdk_checksum_func_escape_text'
    );
  }
  if (
    nativeModule().ubrn_uniffi_vella_sdk_checksum_func_parse_batch_response() !==
    14624
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_vella_sdk_checksum_func_parse_batch_response'
    );
  }
  if (
    nativeModule().ubrn_uniffi_vella_sdk_checksum_func_parse_email() !== 23062
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_vella_sdk_checksum_func_parse_email'
    );
  }
  if (
    nativeModule().ubrn_uniffi_vella_sdk_checksum_func_parse_visible_html() !==
    14978
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_vella_sdk_checksum_func_parse_visible_html'
    );
  }
  if (
    nativeModule().ubrn_uniffi_vella_sdk_checksum_func_parse_visible_text() !==
    17560
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_vella_sdk_checksum_func_parse_visible_text'
    );
  }
}

export default Object.freeze({
  initialize: uniffiEnsureInitialized,
  converters: {
    FfiConverterTypeBatchResponse,
    FfiConverterTypeBatchSection,
    FfiConverterTypeEmail,
    FfiConverterTypeEmailAddress,
    FfiConverterTypeEmailAddressWithText,
    FfiConverterTypeEmailText,
    FfiConverterTypeGmailError,
    FfiConverterTypeGmailErrorItem,
    FfiConverterTypeGmailMessage,
    FfiConverterTypeHeader,
  },
});
