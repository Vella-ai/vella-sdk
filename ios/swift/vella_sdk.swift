// This file was autogenerated by some hot garbage in the `uniffi` crate.
// Trust me, you don't want to mess with it!

// swiftlint:disable all
import Foundation

// Depending on the consumer's build setup, the low-level FFI code
// might be in a separate module, or it might be compiled inline into
// this module. This is a bit of light hackery to work with both.
#if canImport(vella_sdkFFI)
import vella_sdkFFI
#endif

fileprivate extension RustBuffer {
    // Allocate a new buffer, copying the contents of a `UInt8` array.
    init(bytes: [UInt8]) {
        let rbuf = bytes.withUnsafeBufferPointer { ptr in
            RustBuffer.from(ptr)
        }
        self.init(capacity: rbuf.capacity, len: rbuf.len, data: rbuf.data)
    }

    static func empty() -> RustBuffer {
        RustBuffer(capacity: 0, len:0, data: nil)
    }

    static func from(_ ptr: UnsafeBufferPointer<UInt8>) -> RustBuffer {
        try! rustCall { ffi_vella_sdk_rustbuffer_from_bytes(ForeignBytes(bufferPointer: ptr), $0) }
    }

    // Frees the buffer in place.
    // The buffer must not be used after this is called.
    func deallocate() {
        try! rustCall { ffi_vella_sdk_rustbuffer_free(self, $0) }
    }
}

fileprivate extension ForeignBytes {
    init(bufferPointer: UnsafeBufferPointer<UInt8>) {
        self.init(len: Int32(bufferPointer.count), data: bufferPointer.baseAddress)
    }
}

// For every type used in the interface, we provide helper methods for conveniently
// lifting and lowering that type from C-compatible data, and for reading and writing
// values of that type in a buffer.

// Helper classes/extensions that don't change.
// Someday, this will be in a library of its own.

fileprivate extension Data {
    init(rustBuffer: RustBuffer) {
        self.init(
            bytesNoCopy: rustBuffer.data!,
            count: Int(rustBuffer.len),
            deallocator: .none
        )
    }
}

// Define reader functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.
//
// With external types, one swift source file needs to be able to call the read
// method on another source file's FfiConverter, but then what visibility
// should Reader have?
// - If Reader is fileprivate, then this means the read() must also
//   be fileprivate, which doesn't work with external types.
// - If Reader is internal/public, we'll get compile errors since both source
//   files will try define the same type.
//
// Instead, the read() method and these helper functions input a tuple of data

fileprivate func createReader(data: Data) -> (data: Data, offset: Data.Index) {
    (data: data, offset: 0)
}

// Reads an integer at the current offset, in big-endian order, and advances
// the offset on success. Throws if reading the integer would move the
// offset past the end of the buffer.
fileprivate func readInt<T: FixedWidthInteger>(_ reader: inout (data: Data, offset: Data.Index)) throws -> T {
    let range = reader.offset..<reader.offset + MemoryLayout<T>.size
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    if T.self == UInt8.self {
        let value = reader.data[reader.offset]
        reader.offset += 1
        return value as! T
    }
    var value: T = 0
    let _ = withUnsafeMutableBytes(of: &value, { reader.data.copyBytes(to: $0, from: range)})
    reader.offset = range.upperBound
    return value.bigEndian
}

// Reads an arbitrary number of bytes, to be used to read
// raw bytes, this is useful when lifting strings
fileprivate func readBytes(_ reader: inout (data: Data, offset: Data.Index), count: Int) throws -> Array<UInt8> {
    let range = reader.offset..<(reader.offset+count)
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    var value = [UInt8](repeating: 0, count: count)
    value.withUnsafeMutableBufferPointer({ buffer in
        reader.data.copyBytes(to: buffer, from: range)
    })
    reader.offset = range.upperBound
    return value
}

// Reads a float at the current offset.
fileprivate func readFloat(_ reader: inout (data: Data, offset: Data.Index)) throws -> Float {
    return Float(bitPattern: try readInt(&reader))
}

// Reads a float at the current offset.
fileprivate func readDouble(_ reader: inout (data: Data, offset: Data.Index)) throws -> Double {
    return Double(bitPattern: try readInt(&reader))
}

// Indicates if the offset has reached the end of the buffer.
fileprivate func hasRemaining(_ reader: (data: Data, offset: Data.Index)) -> Bool {
    return reader.offset < reader.data.count
}

// Define writer functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.  See the above discussion on Readers for details.

fileprivate func createWriter() -> [UInt8] {
    return []
}

fileprivate func writeBytes<S>(_ writer: inout [UInt8], _ byteArr: S) where S: Sequence, S.Element == UInt8 {
    writer.append(contentsOf: byteArr)
}

// Writes an integer in big-endian order.
//
// Warning: make sure what you are trying to write
// is in the correct type!
fileprivate func writeInt<T: FixedWidthInteger>(_ writer: inout [UInt8], _ value: T) {
    var value = value.bigEndian
    withUnsafeBytes(of: &value) { writer.append(contentsOf: $0) }
}

fileprivate func writeFloat(_ writer: inout [UInt8], _ value: Float) {
    writeInt(&writer, value.bitPattern)
}

fileprivate func writeDouble(_ writer: inout [UInt8], _ value: Double) {
    writeInt(&writer, value.bitPattern)
}

// Protocol for types that transfer other types across the FFI. This is
// analogous to the Rust trait of the same name.
fileprivate protocol FfiConverter {
    associatedtype FfiType
    associatedtype SwiftType

    static func lift(_ value: FfiType) throws -> SwiftType
    static func lower(_ value: SwiftType) -> FfiType
    static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType
    static func write(_ value: SwiftType, into buf: inout [UInt8])
}

// Types conforming to `Primitive` pass themselves directly over the FFI.
fileprivate protocol FfiConverterPrimitive: FfiConverter where FfiType == SwiftType { }

extension FfiConverterPrimitive {
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lift(_ value: FfiType) throws -> SwiftType {
        return value
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lower(_ value: SwiftType) -> FfiType {
        return value
    }
}

// Types conforming to `FfiConverterRustBuffer` lift and lower into a `RustBuffer`.
// Used for complex types where it's hard to write a custom lift/lower.
fileprivate protocol FfiConverterRustBuffer: FfiConverter where FfiType == RustBuffer {}

extension FfiConverterRustBuffer {
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lift(_ buf: RustBuffer) throws -> SwiftType {
        var reader = createReader(data: Data(rustBuffer: buf))
        let value = try read(from: &reader)
        if hasRemaining(reader) {
            throw UniffiInternalError.incompleteData
        }
        buf.deallocate()
        return value
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lower(_ value: SwiftType) -> RustBuffer {
          var writer = createWriter()
          write(value, into: &writer)
          return RustBuffer(bytes: writer)
    }
}
// An error type for FFI errors. These errors occur at the UniFFI level, not
// the library level.
fileprivate enum UniffiInternalError: LocalizedError {
    case bufferOverflow
    case incompleteData
    case unexpectedOptionalTag
    case unexpectedEnumCase
    case unexpectedNullPointer
    case unexpectedRustCallStatusCode
    case unexpectedRustCallError
    case unexpectedStaleHandle
    case rustPanic(_ message: String)

    public var errorDescription: String? {
        switch self {
        case .bufferOverflow: return "Reading the requested value would read past the end of the buffer"
        case .incompleteData: return "The buffer still has data after lifting its containing value"
        case .unexpectedOptionalTag: return "Unexpected optional tag; should be 0 or 1"
        case .unexpectedEnumCase: return "Raw enum value doesn't match any cases"
        case .unexpectedNullPointer: return "Raw pointer value was null"
        case .unexpectedRustCallStatusCode: return "Unexpected RustCallStatus code"
        case .unexpectedRustCallError: return "CALL_ERROR but no errorClass specified"
        case .unexpectedStaleHandle: return "The object in the handle map has been dropped already"
        case let .rustPanic(message): return message
        }
    }
}

fileprivate extension NSLock {
    func withLock<T>(f: () throws -> T) rethrows -> T {
        self.lock()
        defer { self.unlock() }
        return try f()
    }
}

fileprivate let CALL_SUCCESS: Int8 = 0
fileprivate let CALL_ERROR: Int8 = 1
fileprivate let CALL_UNEXPECTED_ERROR: Int8 = 2
fileprivate let CALL_CANCELLED: Int8 = 3

fileprivate extension RustCallStatus {
    init() {
        self.init(
            code: CALL_SUCCESS,
            errorBuf: RustBuffer.init(
                capacity: 0,
                len: 0,
                data: nil
            )
        )
    }
}

private func rustCall<T>(_ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    let neverThrow: ((RustBuffer) throws -> Never)? = nil
    return try makeRustCall(callback, errorHandler: neverThrow)
}

private func rustCallWithError<T, E: Swift.Error>(
    _ errorHandler: @escaping (RustBuffer) throws -> E,
    _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    try makeRustCall(callback, errorHandler: errorHandler)
}

private func makeRustCall<T, E: Swift.Error>(
    _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T,
    errorHandler: ((RustBuffer) throws -> E)?
) throws -> T {
    uniffiEnsureVellaSdkInitialized()
    var callStatus = RustCallStatus.init()
    let returnedVal = callback(&callStatus)
    try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: errorHandler)
    return returnedVal
}

private func uniffiCheckCallStatus<E: Swift.Error>(
    callStatus: RustCallStatus,
    errorHandler: ((RustBuffer) throws -> E)?
) throws {
    switch callStatus.code {
        case CALL_SUCCESS:
            return

        case CALL_ERROR:
            if let errorHandler = errorHandler {
                throw try errorHandler(callStatus.errorBuf)
            } else {
                callStatus.errorBuf.deallocate()
                throw UniffiInternalError.unexpectedRustCallError
            }

        case CALL_UNEXPECTED_ERROR:
            // When the rust code sees a panic, it tries to construct a RustBuffer
            // with the message.  But if that code panics, then it just sends back
            // an empty buffer.
            if callStatus.errorBuf.len > 0 {
                throw UniffiInternalError.rustPanic(try FfiConverterString.lift(callStatus.errorBuf))
            } else {
                callStatus.errorBuf.deallocate()
                throw UniffiInternalError.rustPanic("Rust panic")
            }

        case CALL_CANCELLED:
            fatalError("Cancellation not supported yet")

        default:
            throw UniffiInternalError.unexpectedRustCallStatusCode
    }
}

private func uniffiTraitInterfaceCall<T>(
    callStatus: UnsafeMutablePointer<RustCallStatus>,
    makeCall: () throws -> T,
    writeReturn: (T) -> ()
) {
    do {
        try writeReturn(makeCall())
    } catch let error {
        callStatus.pointee.code = CALL_UNEXPECTED_ERROR
        callStatus.pointee.errorBuf = FfiConverterString.lower(String(describing: error))
    }
}

private func uniffiTraitInterfaceCallWithError<T, E>(
    callStatus: UnsafeMutablePointer<RustCallStatus>,
    makeCall: () throws -> T,
    writeReturn: (T) -> (),
    lowerError: (E) -> RustBuffer
) {
    do {
        try writeReturn(makeCall())
    } catch let error as E {
        callStatus.pointee.code = CALL_ERROR
        callStatus.pointee.errorBuf = lowerError(error)
    } catch {
        callStatus.pointee.code = CALL_UNEXPECTED_ERROR
        callStatus.pointee.errorBuf = FfiConverterString.lower(String(describing: error))
    }
}
fileprivate final class UniffiHandleMap<T>: @unchecked Sendable {
    // All mutation happens with this lock held, which is why we implement @unchecked Sendable.
    private let lock = NSLock()
    private var map: [UInt64: T] = [:]
    private var currentHandle: UInt64 = 1

    func insert(obj: T) -> UInt64 {
        lock.withLock {
            let handle = currentHandle
            currentHandle += 1
            map[handle] = obj
            return handle
        }
    }

     func get(handle: UInt64) throws -> T {
        try lock.withLock {
            guard let obj = map[handle] else {
                throw UniffiInternalError.unexpectedStaleHandle
            }
            return obj
        }
    }

    @discardableResult
    func remove(handle: UInt64) throws -> T {
        try lock.withLock {
            guard let obj = map.removeValue(forKey: handle) else {
                throw UniffiInternalError.unexpectedStaleHandle
            }
            return obj
        }
    }

    var count: Int {
        get {
            map.count
        }
    }
}


// Public interface members begin here.


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterUInt32: FfiConverterPrimitive {
    typealias FfiType = UInt32
    typealias SwiftType = UInt32

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt32 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterInt64: FfiConverterPrimitive {
    typealias FfiType = Int64
    typealias SwiftType = Int64

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Int64 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Int64, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterString: FfiConverter {
    typealias SwiftType = String
    typealias FfiType = RustBuffer

    public static func lift(_ value: RustBuffer) throws -> String {
        defer {
            value.deallocate()
        }
        if value.data == nil {
            return String()
        }
        let bytes = UnsafeBufferPointer<UInt8>(start: value.data!, count: Int(value.len))
        return String(bytes: bytes, encoding: String.Encoding.utf8)!
    }

    public static func lower(_ value: String) -> RustBuffer {
        return value.utf8CString.withUnsafeBufferPointer { ptr in
            // The swift string gives us int8_t, we want uint8_t.
            ptr.withMemoryRebound(to: UInt8.self) { ptr in
                // The swift string gives us a trailing null byte, we don't want it.
                let buf = UnsafeBufferPointer(rebasing: ptr.prefix(upTo: ptr.count - 1))
                return RustBuffer.from(buf)
            }
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> String {
        let len: Int32 = try readInt(&buf)
        return String(bytes: try readBytes(&buf, count: Int(len)), encoding: String.Encoding.utf8)!
    }

    public static func write(_ value: String, into buf: inout [UInt8]) {
        let len = Int32(value.utf8.count)
        writeInt(&buf, len)
        writeBytes(&buf, value.utf8)
    }
}




/**
 * A tokenizer object from a custom dictionary.
 */
public protocol CustomTokenizerInnerProtocol: AnyObject {
    
    /**
     * Decode a given list of token ids, back to a string
     */
    func decode(tokens: [UInt32], specialTokens: SpecialTokens)  -> String?
    
    /**
     * Tokenizes an input string and return a list of token IDs.
     */
    func getIds(input: String, specialTokens: SpecialTokens) throws  -> [UInt32]
    
    /**
     * Gets the configured pad token.
     */
    func getPadToken()  -> ReturnToken?
    
    /**
     * Tokenizes an input string and returns a list of token strings.
     */
    func getTokens(input: String, specialTokens: SpecialTokens) throws  -> [String]
    
    /**
     * Gets the string value of a given token ID.
     */
    func idToToken(id: UInt32)  -> String?
    
    /**
     * Gets the ID value of a given token.
     */
    func tokenToId(token: String)  -> UInt32?
    
    /**
     * Tokenizes an input string and returns a list of tokens.
     */
    func tokenize(input: String, specialTokens: SpecialTokens) throws  -> [Token]
    
    /**
     * Tokenizes a list of input strings and returns a list of token IDs.
     */
    func tokenizeBatch(input: [String], specialTokens: SpecialTokens) throws  -> TokenizedBatch
    
}
/**
 * A tokenizer object from a custom dictionary.
 */
open class CustomTokenizerInner: CustomTokenizerInnerProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_vella_sdk_fn_clone_customtokenizerinner(self.pointer, $0) }
    }
    /**
     * Creates a new custom tokenizer.
     */
public convenience init(dictionary: String, padding: PaddingParams?, truncation: TruncationParams?)throws  {
    let pointer =
        try rustCallWithError(FfiConverterTypeTokenizeError_lift) {
    uniffi_vella_sdk_fn_constructor_customtokenizerinner_new(
        FfiConverterString.lower(dictionary),
        FfiConverterOptionTypePaddingParams.lower(padding),
        FfiConverterOptionTypeTruncationParams.lower(truncation),$0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_vella_sdk_fn_free_customtokenizerinner(pointer, $0) }
    }

    

    
    /**
     * Decode a given list of token ids, back to a string
     */
open func decode(tokens: [UInt32], specialTokens: SpecialTokens) -> String?  {
    return try!  FfiConverterOptionString.lift(try! rustCall() {
    uniffi_vella_sdk_fn_method_customtokenizerinner_decode(self.uniffiClonePointer(),
        FfiConverterSequenceUInt32.lower(tokens),
        FfiConverterTypeSpecialTokens_lower(specialTokens),$0
    )
})
}
    
    /**
     * Tokenizes an input string and return a list of token IDs.
     */
open func getIds(input: String, specialTokens: SpecialTokens)throws  -> [UInt32]  {
    return try  FfiConverterSequenceUInt32.lift(try rustCallWithError(FfiConverterTypeTokenizeError_lift) {
    uniffi_vella_sdk_fn_method_customtokenizerinner_get_ids(self.uniffiClonePointer(),
        FfiConverterString.lower(input),
        FfiConverterTypeSpecialTokens_lower(specialTokens),$0
    )
})
}
    
    /**
     * Gets the configured pad token.
     */
open func getPadToken() -> ReturnToken?  {
    return try!  FfiConverterOptionTypeReturnToken.lift(try! rustCall() {
    uniffi_vella_sdk_fn_method_customtokenizerinner_get_pad_token(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Tokenizes an input string and returns a list of token strings.
     */
open func getTokens(input: String, specialTokens: SpecialTokens)throws  -> [String]  {
    return try  FfiConverterSequenceString.lift(try rustCallWithError(FfiConverterTypeTokenizeError_lift) {
    uniffi_vella_sdk_fn_method_customtokenizerinner_get_tokens(self.uniffiClonePointer(),
        FfiConverterString.lower(input),
        FfiConverterTypeSpecialTokens_lower(specialTokens),$0
    )
})
}
    
    /**
     * Gets the string value of a given token ID.
     */
open func idToToken(id: UInt32) -> String?  {
    return try!  FfiConverterOptionString.lift(try! rustCall() {
    uniffi_vella_sdk_fn_method_customtokenizerinner_id_to_token(self.uniffiClonePointer(),
        FfiConverterUInt32.lower(id),$0
    )
})
}
    
    /**
     * Gets the ID value of a given token.
     */
open func tokenToId(token: String) -> UInt32?  {
    return try!  FfiConverterOptionUInt32.lift(try! rustCall() {
    uniffi_vella_sdk_fn_method_customtokenizerinner_token_to_id(self.uniffiClonePointer(),
        FfiConverterString.lower(token),$0
    )
})
}
    
    /**
     * Tokenizes an input string and returns a list of tokens.
     */
open func tokenize(input: String, specialTokens: SpecialTokens)throws  -> [Token]  {
    return try  FfiConverterSequenceTypeToken.lift(try rustCallWithError(FfiConverterTypeTokenizeError_lift) {
    uniffi_vella_sdk_fn_method_customtokenizerinner_tokenize(self.uniffiClonePointer(),
        FfiConverterString.lower(input),
        FfiConverterTypeSpecialTokens_lower(specialTokens),$0
    )
})
}
    
    /**
     * Tokenizes a list of input strings and returns a list of token IDs.
     */
open func tokenizeBatch(input: [String], specialTokens: SpecialTokens)throws  -> TokenizedBatch  {
    return try  FfiConverterTypeTokenizedBatch_lift(try rustCallWithError(FfiConverterTypeTokenizeError_lift) {
    uniffi_vella_sdk_fn_method_customtokenizerinner_tokenize_batch(self.uniffiClonePointer(),
        FfiConverterSequenceString.lower(input),
        FfiConverterTypeSpecialTokens_lower(specialTokens),$0
    )
})
}
    

}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeCustomTokenizerInner: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = CustomTokenizerInner

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> CustomTokenizerInner {
        return CustomTokenizerInner(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: CustomTokenizerInner) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CustomTokenizerInner {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: CustomTokenizerInner, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCustomTokenizerInner_lift(_ pointer: UnsafeMutableRawPointer) throws -> CustomTokenizerInner {
    return try FfiConverterTypeCustomTokenizerInner.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCustomTokenizerInner_lower(_ value: CustomTokenizerInner) -> UnsafeMutableRawPointer {
    return FfiConverterTypeCustomTokenizerInner.lower(value)
}




public struct BatchSection {
    public var batchName: String
    public var response: BatchResponse

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(batchName: String, response: BatchResponse) {
        self.batchName = batchName
        self.response = response
    }
}

#if compiler(>=6)
extension BatchSection: Sendable {}
#endif


extension BatchSection: Equatable, Hashable {
    public static func ==(lhs: BatchSection, rhs: BatchSection) -> Bool {
        if lhs.batchName != rhs.batchName {
            return false
        }
        if lhs.response != rhs.response {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(batchName)
        hasher.combine(response)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeBatchSection: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> BatchSection {
        return
            try BatchSection(
                batchName: FfiConverterString.read(from: &buf), 
                response: FfiConverterTypeBatchResponse.read(from: &buf)
        )
    }

    public static func write(_ value: BatchSection, into buf: inout [UInt8]) {
        FfiConverterString.write(value.batchName, into: &buf)
        FfiConverterTypeBatchResponse.write(value.response, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBatchSection_lift(_ buf: RustBuffer) throws -> BatchSection {
    return try FfiConverterTypeBatchSection.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBatchSection_lower(_ value: BatchSection) -> RustBuffer {
    return FfiConverterTypeBatchSection.lower(value)
}


public struct CalendarEvent {
    public var uid: String?
    public var summary: String?
    public var status: CalendarEventStatus?
    public var url: String?
    public var googleConferenceLink: String?
    public var location: String?
    public var timestamp: Int64?
    public var lastModified: Int64?
    public var created: Int64?
    public var start: Int64?
    public var end: Int64?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(uid: String?, summary: String?, status: CalendarEventStatus?, url: String?, googleConferenceLink: String?, location: String?, timestamp: Int64?, lastModified: Int64?, created: Int64?, start: Int64?, end: Int64?) {
        self.uid = uid
        self.summary = summary
        self.status = status
        self.url = url
        self.googleConferenceLink = googleConferenceLink
        self.location = location
        self.timestamp = timestamp
        self.lastModified = lastModified
        self.created = created
        self.start = start
        self.end = end
    }
}

#if compiler(>=6)
extension CalendarEvent: Sendable {}
#endif


extension CalendarEvent: Equatable, Hashable {
    public static func ==(lhs: CalendarEvent, rhs: CalendarEvent) -> Bool {
        if lhs.uid != rhs.uid {
            return false
        }
        if lhs.summary != rhs.summary {
            return false
        }
        if lhs.status != rhs.status {
            return false
        }
        if lhs.url != rhs.url {
            return false
        }
        if lhs.googleConferenceLink != rhs.googleConferenceLink {
            return false
        }
        if lhs.location != rhs.location {
            return false
        }
        if lhs.timestamp != rhs.timestamp {
            return false
        }
        if lhs.lastModified != rhs.lastModified {
            return false
        }
        if lhs.created != rhs.created {
            return false
        }
        if lhs.start != rhs.start {
            return false
        }
        if lhs.end != rhs.end {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(uid)
        hasher.combine(summary)
        hasher.combine(status)
        hasher.combine(url)
        hasher.combine(googleConferenceLink)
        hasher.combine(location)
        hasher.combine(timestamp)
        hasher.combine(lastModified)
        hasher.combine(created)
        hasher.combine(start)
        hasher.combine(end)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeCalendarEvent: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CalendarEvent {
        return
            try CalendarEvent(
                uid: FfiConverterOptionString.read(from: &buf), 
                summary: FfiConverterOptionString.read(from: &buf), 
                status: FfiConverterOptionTypeCalendarEventStatus.read(from: &buf), 
                url: FfiConverterOptionString.read(from: &buf), 
                googleConferenceLink: FfiConverterOptionString.read(from: &buf), 
                location: FfiConverterOptionString.read(from: &buf), 
                timestamp: FfiConverterOptionInt64.read(from: &buf), 
                lastModified: FfiConverterOptionInt64.read(from: &buf), 
                created: FfiConverterOptionInt64.read(from: &buf), 
                start: FfiConverterOptionInt64.read(from: &buf), 
                end: FfiConverterOptionInt64.read(from: &buf)
        )
    }

    public static func write(_ value: CalendarEvent, into buf: inout [UInt8]) {
        FfiConverterOptionString.write(value.uid, into: &buf)
        FfiConverterOptionString.write(value.summary, into: &buf)
        FfiConverterOptionTypeCalendarEventStatus.write(value.status, into: &buf)
        FfiConverterOptionString.write(value.url, into: &buf)
        FfiConverterOptionString.write(value.googleConferenceLink, into: &buf)
        FfiConverterOptionString.write(value.location, into: &buf)
        FfiConverterOptionInt64.write(value.timestamp, into: &buf)
        FfiConverterOptionInt64.write(value.lastModified, into: &buf)
        FfiConverterOptionInt64.write(value.created, into: &buf)
        FfiConverterOptionInt64.write(value.start, into: &buf)
        FfiConverterOptionInt64.write(value.end, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCalendarEvent_lift(_ buf: RustBuffer) throws -> CalendarEvent {
    return try FfiConverterTypeCalendarEvent.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCalendarEvent_lower(_ value: CalendarEvent) -> RustBuffer {
    return FfiConverterTypeCalendarEvent.lower(value)
}


public struct Email {
    public var from: EmailAddressWithText
    public var fromAddresses: [EmailAddress]
    public var to: EmailAddressWithText
    public var toAddresses: [EmailAddress]
    public var ccAddresses: [EmailAddress]
    public var bccAddresses: [EmailAddress]
    public var subject: String?
    /**
     * Unix epoch in seconds
     */
    public var date: Int64?
    public var contentId: String?
    public var messageId: String?
    public var threadName: String?
    public var mimeVersion: String?
    public var headers: [Header]
    public var textBodies: [EmailText]
    public var htmlBodies: [EmailText]
    public var markups: [String]
    public var calendarEvents: [CalendarEvent]
    public var microdataItems: [MicrodataItem]
    public var unsubscribe: Unsubscribe

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(from: EmailAddressWithText, fromAddresses: [EmailAddress], to: EmailAddressWithText, toAddresses: [EmailAddress], ccAddresses: [EmailAddress], bccAddresses: [EmailAddress], subject: String?, 
        /**
         * Unix epoch in seconds
         */date: Int64?, contentId: String?, messageId: String?, threadName: String?, mimeVersion: String?, headers: [Header], textBodies: [EmailText], htmlBodies: [EmailText], markups: [String], calendarEvents: [CalendarEvent], microdataItems: [MicrodataItem], unsubscribe: Unsubscribe) {
        self.from = from
        self.fromAddresses = fromAddresses
        self.to = to
        self.toAddresses = toAddresses
        self.ccAddresses = ccAddresses
        self.bccAddresses = bccAddresses
        self.subject = subject
        self.date = date
        self.contentId = contentId
        self.messageId = messageId
        self.threadName = threadName
        self.mimeVersion = mimeVersion
        self.headers = headers
        self.textBodies = textBodies
        self.htmlBodies = htmlBodies
        self.markups = markups
        self.calendarEvents = calendarEvents
        self.microdataItems = microdataItems
        self.unsubscribe = unsubscribe
    }
}

#if compiler(>=6)
extension Email: Sendable {}
#endif


extension Email: Equatable, Hashable {
    public static func ==(lhs: Email, rhs: Email) -> Bool {
        if lhs.from != rhs.from {
            return false
        }
        if lhs.fromAddresses != rhs.fromAddresses {
            return false
        }
        if lhs.to != rhs.to {
            return false
        }
        if lhs.toAddresses != rhs.toAddresses {
            return false
        }
        if lhs.ccAddresses != rhs.ccAddresses {
            return false
        }
        if lhs.bccAddresses != rhs.bccAddresses {
            return false
        }
        if lhs.subject != rhs.subject {
            return false
        }
        if lhs.date != rhs.date {
            return false
        }
        if lhs.contentId != rhs.contentId {
            return false
        }
        if lhs.messageId != rhs.messageId {
            return false
        }
        if lhs.threadName != rhs.threadName {
            return false
        }
        if lhs.mimeVersion != rhs.mimeVersion {
            return false
        }
        if lhs.headers != rhs.headers {
            return false
        }
        if lhs.textBodies != rhs.textBodies {
            return false
        }
        if lhs.htmlBodies != rhs.htmlBodies {
            return false
        }
        if lhs.markups != rhs.markups {
            return false
        }
        if lhs.calendarEvents != rhs.calendarEvents {
            return false
        }
        if lhs.microdataItems != rhs.microdataItems {
            return false
        }
        if lhs.unsubscribe != rhs.unsubscribe {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(from)
        hasher.combine(fromAddresses)
        hasher.combine(to)
        hasher.combine(toAddresses)
        hasher.combine(ccAddresses)
        hasher.combine(bccAddresses)
        hasher.combine(subject)
        hasher.combine(date)
        hasher.combine(contentId)
        hasher.combine(messageId)
        hasher.combine(threadName)
        hasher.combine(mimeVersion)
        hasher.combine(headers)
        hasher.combine(textBodies)
        hasher.combine(htmlBodies)
        hasher.combine(markups)
        hasher.combine(calendarEvents)
        hasher.combine(microdataItems)
        hasher.combine(unsubscribe)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeEmail: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Email {
        return
            try Email(
                from: FfiConverterTypeEmailAddressWithText.read(from: &buf), 
                fromAddresses: FfiConverterSequenceTypeEmailAddress.read(from: &buf), 
                to: FfiConverterTypeEmailAddressWithText.read(from: &buf), 
                toAddresses: FfiConverterSequenceTypeEmailAddress.read(from: &buf), 
                ccAddresses: FfiConverterSequenceTypeEmailAddress.read(from: &buf), 
                bccAddresses: FfiConverterSequenceTypeEmailAddress.read(from: &buf), 
                subject: FfiConverterOptionString.read(from: &buf), 
                date: FfiConverterOptionInt64.read(from: &buf), 
                contentId: FfiConverterOptionString.read(from: &buf), 
                messageId: FfiConverterOptionString.read(from: &buf), 
                threadName: FfiConverterOptionString.read(from: &buf), 
                mimeVersion: FfiConverterOptionString.read(from: &buf), 
                headers: FfiConverterSequenceTypeHeader.read(from: &buf), 
                textBodies: FfiConverterSequenceTypeEmailText.read(from: &buf), 
                htmlBodies: FfiConverterSequenceTypeEmailText.read(from: &buf), 
                markups: FfiConverterSequenceString.read(from: &buf), 
                calendarEvents: FfiConverterSequenceTypeCalendarEvent.read(from: &buf), 
                microdataItems: FfiConverterSequenceTypeMicrodataItem.read(from: &buf), 
                unsubscribe: FfiConverterTypeUnsubscribe.read(from: &buf)
        )
    }

    public static func write(_ value: Email, into buf: inout [UInt8]) {
        FfiConverterTypeEmailAddressWithText.write(value.from, into: &buf)
        FfiConverterSequenceTypeEmailAddress.write(value.fromAddresses, into: &buf)
        FfiConverterTypeEmailAddressWithText.write(value.to, into: &buf)
        FfiConverterSequenceTypeEmailAddress.write(value.toAddresses, into: &buf)
        FfiConverterSequenceTypeEmailAddress.write(value.ccAddresses, into: &buf)
        FfiConverterSequenceTypeEmailAddress.write(value.bccAddresses, into: &buf)
        FfiConverterOptionString.write(value.subject, into: &buf)
        FfiConverterOptionInt64.write(value.date, into: &buf)
        FfiConverterOptionString.write(value.contentId, into: &buf)
        FfiConverterOptionString.write(value.messageId, into: &buf)
        FfiConverterOptionString.write(value.threadName, into: &buf)
        FfiConverterOptionString.write(value.mimeVersion, into: &buf)
        FfiConverterSequenceTypeHeader.write(value.headers, into: &buf)
        FfiConverterSequenceTypeEmailText.write(value.textBodies, into: &buf)
        FfiConverterSequenceTypeEmailText.write(value.htmlBodies, into: &buf)
        FfiConverterSequenceString.write(value.markups, into: &buf)
        FfiConverterSequenceTypeCalendarEvent.write(value.calendarEvents, into: &buf)
        FfiConverterSequenceTypeMicrodataItem.write(value.microdataItems, into: &buf)
        FfiConverterTypeUnsubscribe.write(value.unsubscribe, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeEmail_lift(_ buf: RustBuffer) throws -> Email {
    return try FfiConverterTypeEmail.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeEmail_lower(_ value: Email) -> RustBuffer {
    return FfiConverterTypeEmail.lower(value)
}


public struct EmailAddress {
    public var name: String?
    public var address: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(name: String?, address: String) {
        self.name = name
        self.address = address
    }
}

#if compiler(>=6)
extension EmailAddress: Sendable {}
#endif


extension EmailAddress: Equatable, Hashable {
    public static func ==(lhs: EmailAddress, rhs: EmailAddress) -> Bool {
        if lhs.name != rhs.name {
            return false
        }
        if lhs.address != rhs.address {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(name)
        hasher.combine(address)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeEmailAddress: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> EmailAddress {
        return
            try EmailAddress(
                name: FfiConverterOptionString.read(from: &buf), 
                address: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: EmailAddress, into buf: inout [UInt8]) {
        FfiConverterOptionString.write(value.name, into: &buf)
        FfiConverterString.write(value.address, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeEmailAddress_lift(_ buf: RustBuffer) throws -> EmailAddress {
    return try FfiConverterTypeEmailAddress.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeEmailAddress_lower(_ value: EmailAddress) -> RustBuffer {
    return FfiConverterTypeEmailAddress.lower(value)
}


public struct EmailAddressWithText {
    public var name: String?
    public var text: String
    public var address: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(name: String?, text: String, address: String) {
        self.name = name
        self.text = text
        self.address = address
    }
}

#if compiler(>=6)
extension EmailAddressWithText: Sendable {}
#endif


extension EmailAddressWithText: Equatable, Hashable {
    public static func ==(lhs: EmailAddressWithText, rhs: EmailAddressWithText) -> Bool {
        if lhs.name != rhs.name {
            return false
        }
        if lhs.text != rhs.text {
            return false
        }
        if lhs.address != rhs.address {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(name)
        hasher.combine(text)
        hasher.combine(address)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeEmailAddressWithText: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> EmailAddressWithText {
        return
            try EmailAddressWithText(
                name: FfiConverterOptionString.read(from: &buf), 
                text: FfiConverterString.read(from: &buf), 
                address: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: EmailAddressWithText, into buf: inout [UInt8]) {
        FfiConverterOptionString.write(value.name, into: &buf)
        FfiConverterString.write(value.text, into: &buf)
        FfiConverterString.write(value.address, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeEmailAddressWithText_lift(_ buf: RustBuffer) throws -> EmailAddressWithText {
    return try FfiConverterTypeEmailAddressWithText.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeEmailAddressWithText_lower(_ value: EmailAddressWithText) -> RustBuffer {
    return FfiConverterTypeEmailAddressWithText.lower(value)
}


public struct EmailText {
    public var text: String
    public var visible: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(text: String, visible: String?) {
        self.text = text
        self.visible = visible
    }
}

#if compiler(>=6)
extension EmailText: Sendable {}
#endif


extension EmailText: Equatable, Hashable {
    public static func ==(lhs: EmailText, rhs: EmailText) -> Bool {
        if lhs.text != rhs.text {
            return false
        }
        if lhs.visible != rhs.visible {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(text)
        hasher.combine(visible)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeEmailText: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> EmailText {
        return
            try EmailText(
                text: FfiConverterString.read(from: &buf), 
                visible: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: EmailText, into buf: inout [UInt8]) {
        FfiConverterString.write(value.text, into: &buf)
        FfiConverterOptionString.write(value.visible, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeEmailText_lift(_ buf: RustBuffer) throws -> EmailText {
    return try FfiConverterTypeEmailText.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeEmailText_lower(_ value: EmailText) -> RustBuffer {
    return FfiConverterTypeEmailText.lower(value)
}


public struct GmailError {
    public var code: UInt32
    public var message: String
    public var status: String
    public var errors: [GmailErrorItem]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(code: UInt32, message: String, status: String, errors: [GmailErrorItem]) {
        self.code = code
        self.message = message
        self.status = status
        self.errors = errors
    }
}

#if compiler(>=6)
extension GmailError: Sendable {}
#endif


extension GmailError: Equatable, Hashable {
    public static func ==(lhs: GmailError, rhs: GmailError) -> Bool {
        if lhs.code != rhs.code {
            return false
        }
        if lhs.message != rhs.message {
            return false
        }
        if lhs.status != rhs.status {
            return false
        }
        if lhs.errors != rhs.errors {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(code)
        hasher.combine(message)
        hasher.combine(status)
        hasher.combine(errors)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeGmailError: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> GmailError {
        return
            try GmailError(
                code: FfiConverterUInt32.read(from: &buf), 
                message: FfiConverterString.read(from: &buf), 
                status: FfiConverterString.read(from: &buf), 
                errors: FfiConverterSequenceTypeGmailErrorItem.read(from: &buf)
        )
    }

    public static func write(_ value: GmailError, into buf: inout [UInt8]) {
        FfiConverterUInt32.write(value.code, into: &buf)
        FfiConverterString.write(value.message, into: &buf)
        FfiConverterString.write(value.status, into: &buf)
        FfiConverterSequenceTypeGmailErrorItem.write(value.errors, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeGmailError_lift(_ buf: RustBuffer) throws -> GmailError {
    return try FfiConverterTypeGmailError.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeGmailError_lower(_ value: GmailError) -> RustBuffer {
    return FfiConverterTypeGmailError.lower(value)
}


public struct GmailErrorItem {
    public var message: String
    public var domain: String
    public var reason: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(message: String, domain: String, reason: String) {
        self.message = message
        self.domain = domain
        self.reason = reason
    }
}

#if compiler(>=6)
extension GmailErrorItem: Sendable {}
#endif


extension GmailErrorItem: Equatable, Hashable {
    public static func ==(lhs: GmailErrorItem, rhs: GmailErrorItem) -> Bool {
        if lhs.message != rhs.message {
            return false
        }
        if lhs.domain != rhs.domain {
            return false
        }
        if lhs.reason != rhs.reason {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(message)
        hasher.combine(domain)
        hasher.combine(reason)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeGmailErrorItem: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> GmailErrorItem {
        return
            try GmailErrorItem(
                message: FfiConverterString.read(from: &buf), 
                domain: FfiConverterString.read(from: &buf), 
                reason: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: GmailErrorItem, into buf: inout [UInt8]) {
        FfiConverterString.write(value.message, into: &buf)
        FfiConverterString.write(value.domain, into: &buf)
        FfiConverterString.write(value.reason, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeGmailErrorItem_lift(_ buf: RustBuffer) throws -> GmailErrorItem {
    return try FfiConverterTypeGmailErrorItem.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeGmailErrorItem_lower(_ value: GmailErrorItem) -> RustBuffer {
    return FfiConverterTypeGmailErrorItem.lower(value)
}


public struct GmailMessage {
    public var id: String
    public var threadId: String
    public var labelIds: [String]
    public var snippet: EmailText
    public var sizeEstimate: UInt32
    public var data: Email
    public var historyId: String
    public var internalDate: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(id: String, threadId: String, labelIds: [String], snippet: EmailText, sizeEstimate: UInt32, data: Email, historyId: String, internalDate: String) {
        self.id = id
        self.threadId = threadId
        self.labelIds = labelIds
        self.snippet = snippet
        self.sizeEstimate = sizeEstimate
        self.data = data
        self.historyId = historyId
        self.internalDate = internalDate
    }
}

#if compiler(>=6)
extension GmailMessage: Sendable {}
#endif


extension GmailMessage: Equatable, Hashable {
    public static func ==(lhs: GmailMessage, rhs: GmailMessage) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.threadId != rhs.threadId {
            return false
        }
        if lhs.labelIds != rhs.labelIds {
            return false
        }
        if lhs.snippet != rhs.snippet {
            return false
        }
        if lhs.sizeEstimate != rhs.sizeEstimate {
            return false
        }
        if lhs.data != rhs.data {
            return false
        }
        if lhs.historyId != rhs.historyId {
            return false
        }
        if lhs.internalDate != rhs.internalDate {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(threadId)
        hasher.combine(labelIds)
        hasher.combine(snippet)
        hasher.combine(sizeEstimate)
        hasher.combine(data)
        hasher.combine(historyId)
        hasher.combine(internalDate)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeGmailMessage: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> GmailMessage {
        return
            try GmailMessage(
                id: FfiConverterString.read(from: &buf), 
                threadId: FfiConverterString.read(from: &buf), 
                labelIds: FfiConverterSequenceString.read(from: &buf), 
                snippet: FfiConverterTypeEmailText.read(from: &buf), 
                sizeEstimate: FfiConverterUInt32.read(from: &buf), 
                data: FfiConverterTypeEmail.read(from: &buf), 
                historyId: FfiConverterString.read(from: &buf), 
                internalDate: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: GmailMessage, into buf: inout [UInt8]) {
        FfiConverterString.write(value.id, into: &buf)
        FfiConverterString.write(value.threadId, into: &buf)
        FfiConverterSequenceString.write(value.labelIds, into: &buf)
        FfiConverterTypeEmailText.write(value.snippet, into: &buf)
        FfiConverterUInt32.write(value.sizeEstimate, into: &buf)
        FfiConverterTypeEmail.write(value.data, into: &buf)
        FfiConverterString.write(value.historyId, into: &buf)
        FfiConverterString.write(value.internalDate, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeGmailMessage_lift(_ buf: RustBuffer) throws -> GmailMessage {
    return try FfiConverterTypeGmailMessage.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeGmailMessage_lower(_ value: GmailMessage) -> RustBuffer {
    return FfiConverterTypeGmailMessage.lower(value)
}


public struct Header {
    public var name: String
    public var value: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(name: String, value: String) {
        self.name = name
        self.value = value
    }
}

#if compiler(>=6)
extension Header: Sendable {}
#endif


extension Header: Equatable, Hashable {
    public static func ==(lhs: Header, rhs: Header) -> Bool {
        if lhs.name != rhs.name {
            return false
        }
        if lhs.value != rhs.value {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(name)
        hasher.combine(value)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeHeader: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Header {
        return
            try Header(
                name: FfiConverterString.read(from: &buf), 
                value: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: Header, into buf: inout [UInt8]) {
        FfiConverterString.write(value.name, into: &buf)
        FfiConverterString.write(value.value, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeHeader_lift(_ buf: RustBuffer) throws -> Header {
    return try FfiConverterTypeHeader.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeHeader_lower(_ value: Header) -> RustBuffer {
    return FfiConverterTypeHeader.lower(value)
}


public struct MicrodataItem {
    public var itemtype: String?
    public var properties: [String: String]
    public var children: [String: MicrodataItem]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(itemtype: String?, properties: [String: String], children: [String: MicrodataItem]) {
        self.itemtype = itemtype
        self.properties = properties
        self.children = children
    }
}

#if compiler(>=6)
extension MicrodataItem: Sendable {}
#endif


extension MicrodataItem: Equatable, Hashable {
    public static func ==(lhs: MicrodataItem, rhs: MicrodataItem) -> Bool {
        if lhs.itemtype != rhs.itemtype {
            return false
        }
        if lhs.properties != rhs.properties {
            return false
        }
        if lhs.children != rhs.children {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(itemtype)
        hasher.combine(properties)
        hasher.combine(children)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeMicrodataItem: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MicrodataItem {
        return
            try MicrodataItem(
                itemtype: FfiConverterOptionString.read(from: &buf), 
                properties: FfiConverterDictionaryStringString.read(from: &buf), 
                children: FfiConverterDictionaryStringTypeMicrodataItem.read(from: &buf)
        )
    }

    public static func write(_ value: MicrodataItem, into buf: inout [UInt8]) {
        FfiConverterOptionString.write(value.itemtype, into: &buf)
        FfiConverterDictionaryStringString.write(value.properties, into: &buf)
        FfiConverterDictionaryStringTypeMicrodataItem.write(value.children, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeMicrodataItem_lift(_ buf: RustBuffer) throws -> MicrodataItem {
    return try FfiConverterTypeMicrodataItem.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeMicrodataItem_lower(_ value: MicrodataItem) -> RustBuffer {
    return FfiConverterTypeMicrodataItem.lower(value)
}


public struct PaddingParams {
    public var strategy: PaddingStrategy
    public var direction: PaddingDirection
    public var padToMultipleOf: UInt32?
    public var padId: UInt32
    public var padTypeId: UInt32
    public var padToken: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(strategy: PaddingStrategy, direction: PaddingDirection, padToMultipleOf: UInt32?, padId: UInt32, padTypeId: UInt32, padToken: String) {
        self.strategy = strategy
        self.direction = direction
        self.padToMultipleOf = padToMultipleOf
        self.padId = padId
        self.padTypeId = padTypeId
        self.padToken = padToken
    }
}

#if compiler(>=6)
extension PaddingParams: Sendable {}
#endif


extension PaddingParams: Equatable, Hashable {
    public static func ==(lhs: PaddingParams, rhs: PaddingParams) -> Bool {
        if lhs.strategy != rhs.strategy {
            return false
        }
        if lhs.direction != rhs.direction {
            return false
        }
        if lhs.padToMultipleOf != rhs.padToMultipleOf {
            return false
        }
        if lhs.padId != rhs.padId {
            return false
        }
        if lhs.padTypeId != rhs.padTypeId {
            return false
        }
        if lhs.padToken != rhs.padToken {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(strategy)
        hasher.combine(direction)
        hasher.combine(padToMultipleOf)
        hasher.combine(padId)
        hasher.combine(padTypeId)
        hasher.combine(padToken)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePaddingParams: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PaddingParams {
        return
            try PaddingParams(
                strategy: FfiConverterTypePaddingStrategy.read(from: &buf), 
                direction: FfiConverterTypePaddingDirection.read(from: &buf), 
                padToMultipleOf: FfiConverterOptionUInt32.read(from: &buf), 
                padId: FfiConverterUInt32.read(from: &buf), 
                padTypeId: FfiConverterUInt32.read(from: &buf), 
                padToken: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: PaddingParams, into buf: inout [UInt8]) {
        FfiConverterTypePaddingStrategy.write(value.strategy, into: &buf)
        FfiConverterTypePaddingDirection.write(value.direction, into: &buf)
        FfiConverterOptionUInt32.write(value.padToMultipleOf, into: &buf)
        FfiConverterUInt32.write(value.padId, into: &buf)
        FfiConverterUInt32.write(value.padTypeId, into: &buf)
        FfiConverterString.write(value.padToken, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePaddingParams_lift(_ buf: RustBuffer) throws -> PaddingParams {
    return try FfiConverterTypePaddingParams.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePaddingParams_lower(_ value: PaddingParams) -> RustBuffer {
    return FfiConverterTypePaddingParams.lower(value)
}


public struct ReturnToken {
    public var id: UInt32
    public var token: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(id: UInt32, token: String) {
        self.id = id
        self.token = token
    }
}

#if compiler(>=6)
extension ReturnToken: Sendable {}
#endif


extension ReturnToken: Equatable, Hashable {
    public static func ==(lhs: ReturnToken, rhs: ReturnToken) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.token != rhs.token {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(token)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeReturnToken: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ReturnToken {
        return
            try ReturnToken(
                id: FfiConverterUInt32.read(from: &buf), 
                token: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: ReturnToken, into buf: inout [UInt8]) {
        FfiConverterUInt32.write(value.id, into: &buf)
        FfiConverterString.write(value.token, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeReturnToken_lift(_ buf: RustBuffer) throws -> ReturnToken {
    return try FfiConverterTypeReturnToken.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeReturnToken_lower(_ value: ReturnToken) -> RustBuffer {
    return FfiConverterTypeReturnToken.lower(value)
}


public struct Token {
    public var id: UInt32
    public var token: String
    public var start: UInt32
    public var end: UInt32

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(id: UInt32, token: String, start: UInt32, end: UInt32) {
        self.id = id
        self.token = token
        self.start = start
        self.end = end
    }
}

#if compiler(>=6)
extension Token: Sendable {}
#endif


extension Token: Equatable, Hashable {
    public static func ==(lhs: Token, rhs: Token) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.token != rhs.token {
            return false
        }
        if lhs.start != rhs.start {
            return false
        }
        if lhs.end != rhs.end {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(token)
        hasher.combine(start)
        hasher.combine(end)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeToken: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Token {
        return
            try Token(
                id: FfiConverterUInt32.read(from: &buf), 
                token: FfiConverterString.read(from: &buf), 
                start: FfiConverterUInt32.read(from: &buf), 
                end: FfiConverterUInt32.read(from: &buf)
        )
    }

    public static func write(_ value: Token, into buf: inout [UInt8]) {
        FfiConverterUInt32.write(value.id, into: &buf)
        FfiConverterString.write(value.token, into: &buf)
        FfiConverterUInt32.write(value.start, into: &buf)
        FfiConverterUInt32.write(value.end, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeToken_lift(_ buf: RustBuffer) throws -> Token {
    return try FfiConverterTypeToken.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeToken_lower(_ value: Token) -> RustBuffer {
    return FfiConverterTypeToken.lower(value)
}


public struct TokenizedBatch {
    public var tokenIds: [[UInt32]]
    public var attentionMask: [[UInt32]]
    public var typeIds: [[UInt32]]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(tokenIds: [[UInt32]], attentionMask: [[UInt32]], typeIds: [[UInt32]]) {
        self.tokenIds = tokenIds
        self.attentionMask = attentionMask
        self.typeIds = typeIds
    }
}

#if compiler(>=6)
extension TokenizedBatch: Sendable {}
#endif


extension TokenizedBatch: Equatable, Hashable {
    public static func ==(lhs: TokenizedBatch, rhs: TokenizedBatch) -> Bool {
        if lhs.tokenIds != rhs.tokenIds {
            return false
        }
        if lhs.attentionMask != rhs.attentionMask {
            return false
        }
        if lhs.typeIds != rhs.typeIds {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(tokenIds)
        hasher.combine(attentionMask)
        hasher.combine(typeIds)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeTokenizedBatch: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TokenizedBatch {
        return
            try TokenizedBatch(
                tokenIds: FfiConverterSequenceSequenceUInt32.read(from: &buf), 
                attentionMask: FfiConverterSequenceSequenceUInt32.read(from: &buf), 
                typeIds: FfiConverterSequenceSequenceUInt32.read(from: &buf)
        )
    }

    public static func write(_ value: TokenizedBatch, into buf: inout [UInt8]) {
        FfiConverterSequenceSequenceUInt32.write(value.tokenIds, into: &buf)
        FfiConverterSequenceSequenceUInt32.write(value.attentionMask, into: &buf)
        FfiConverterSequenceSequenceUInt32.write(value.typeIds, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTokenizedBatch_lift(_ buf: RustBuffer) throws -> TokenizedBatch {
    return try FfiConverterTypeTokenizedBatch.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTokenizedBatch_lower(_ value: TokenizedBatch) -> RustBuffer {
    return FfiConverterTypeTokenizedBatch.lower(value)
}


public struct TruncationParams {
    public var direction: TruncationDirection
    public var maxLength: UInt32
    public var strategy: TruncationStrategy
    public var stride: UInt32

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(direction: TruncationDirection, maxLength: UInt32, strategy: TruncationStrategy, stride: UInt32) {
        self.direction = direction
        self.maxLength = maxLength
        self.strategy = strategy
        self.stride = stride
    }
}

#if compiler(>=6)
extension TruncationParams: Sendable {}
#endif


extension TruncationParams: Equatable, Hashable {
    public static func ==(lhs: TruncationParams, rhs: TruncationParams) -> Bool {
        if lhs.direction != rhs.direction {
            return false
        }
        if lhs.maxLength != rhs.maxLength {
            return false
        }
        if lhs.strategy != rhs.strategy {
            return false
        }
        if lhs.stride != rhs.stride {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(direction)
        hasher.combine(maxLength)
        hasher.combine(strategy)
        hasher.combine(stride)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeTruncationParams: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TruncationParams {
        return
            try TruncationParams(
                direction: FfiConverterTypeTruncationDirection.read(from: &buf), 
                maxLength: FfiConverterUInt32.read(from: &buf), 
                strategy: FfiConverterTypeTruncationStrategy.read(from: &buf), 
                stride: FfiConverterUInt32.read(from: &buf)
        )
    }

    public static func write(_ value: TruncationParams, into buf: inout [UInt8]) {
        FfiConverterTypeTruncationDirection.write(value.direction, into: &buf)
        FfiConverterUInt32.write(value.maxLength, into: &buf)
        FfiConverterTypeTruncationStrategy.write(value.strategy, into: &buf)
        FfiConverterUInt32.write(value.stride, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTruncationParams_lift(_ buf: RustBuffer) throws -> TruncationParams {
    return try FfiConverterTypeTruncationParams.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTruncationParams_lower(_ value: TruncationParams) -> RustBuffer {
    return FfiConverterTypeTruncationParams.lower(value)
}


public struct Unsubscribe {
    public var get: String?
    public var website: String?
    public var post: UnsubscribePost?
    public var email: UnsubscribeEmail?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(get: String?, website: String?, post: UnsubscribePost?, email: UnsubscribeEmail?) {
        self.get = get
        self.website = website
        self.post = post
        self.email = email
    }
}

#if compiler(>=6)
extension Unsubscribe: Sendable {}
#endif


extension Unsubscribe: Equatable, Hashable {
    public static func ==(lhs: Unsubscribe, rhs: Unsubscribe) -> Bool {
        if lhs.get != rhs.get {
            return false
        }
        if lhs.website != rhs.website {
            return false
        }
        if lhs.post != rhs.post {
            return false
        }
        if lhs.email != rhs.email {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(get)
        hasher.combine(website)
        hasher.combine(post)
        hasher.combine(email)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeUnsubscribe: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Unsubscribe {
        return
            try Unsubscribe(
                get: FfiConverterOptionString.read(from: &buf), 
                website: FfiConverterOptionString.read(from: &buf), 
                post: FfiConverterOptionTypeUnsubscribePost.read(from: &buf), 
                email: FfiConverterOptionTypeUnsubscribeEmail.read(from: &buf)
        )
    }

    public static func write(_ value: Unsubscribe, into buf: inout [UInt8]) {
        FfiConverterOptionString.write(value.get, into: &buf)
        FfiConverterOptionString.write(value.website, into: &buf)
        FfiConverterOptionTypeUnsubscribePost.write(value.post, into: &buf)
        FfiConverterOptionTypeUnsubscribeEmail.write(value.email, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeUnsubscribe_lift(_ buf: RustBuffer) throws -> Unsubscribe {
    return try FfiConverterTypeUnsubscribe.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeUnsubscribe_lower(_ value: Unsubscribe) -> RustBuffer {
    return FfiConverterTypeUnsubscribe.lower(value)
}


public struct UnsubscribeEmail {
    public var email: String
    public var headers: [Header]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(email: String, headers: [Header]) {
        self.email = email
        self.headers = headers
    }
}

#if compiler(>=6)
extension UnsubscribeEmail: Sendable {}
#endif


extension UnsubscribeEmail: Equatable, Hashable {
    public static func ==(lhs: UnsubscribeEmail, rhs: UnsubscribeEmail) -> Bool {
        if lhs.email != rhs.email {
            return false
        }
        if lhs.headers != rhs.headers {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(email)
        hasher.combine(headers)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeUnsubscribeEmail: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UnsubscribeEmail {
        return
            try UnsubscribeEmail(
                email: FfiConverterString.read(from: &buf), 
                headers: FfiConverterSequenceTypeHeader.read(from: &buf)
        )
    }

    public static func write(_ value: UnsubscribeEmail, into buf: inout [UInt8]) {
        FfiConverterString.write(value.email, into: &buf)
        FfiConverterSequenceTypeHeader.write(value.headers, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeUnsubscribeEmail_lift(_ buf: RustBuffer) throws -> UnsubscribeEmail {
    return try FfiConverterTypeUnsubscribeEmail.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeUnsubscribeEmail_lower(_ value: UnsubscribeEmail) -> RustBuffer {
    return FfiConverterTypeUnsubscribeEmail.lower(value)
}


public struct UnsubscribePost {
    public var url: String
    public var body: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(url: String, body: String) {
        self.url = url
        self.body = body
    }
}

#if compiler(>=6)
extension UnsubscribePost: Sendable {}
#endif


extension UnsubscribePost: Equatable, Hashable {
    public static func ==(lhs: UnsubscribePost, rhs: UnsubscribePost) -> Bool {
        if lhs.url != rhs.url {
            return false
        }
        if lhs.body != rhs.body {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(url)
        hasher.combine(body)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeUnsubscribePost: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UnsubscribePost {
        return
            try UnsubscribePost(
                url: FfiConverterString.read(from: &buf), 
                body: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: UnsubscribePost, into buf: inout [UInt8]) {
        FfiConverterString.write(value.url, into: &buf)
        FfiConverterString.write(value.body, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeUnsubscribePost_lift(_ buf: RustBuffer) throws -> UnsubscribePost {
    return try FfiConverterTypeUnsubscribePost.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeUnsubscribePost_lower(_ value: UnsubscribePost) -> RustBuffer {
    return FfiConverterTypeUnsubscribePost.lower(value)
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum BatchResponse {
    
    case success(GmailMessage
    )
    case error(GmailError
    )
}


#if compiler(>=6)
extension BatchResponse: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeBatchResponse: FfiConverterRustBuffer {
    typealias SwiftType = BatchResponse

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> BatchResponse {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .success(try FfiConverterTypeGmailMessage.read(from: &buf)
        )
        
        case 2: return .error(try FfiConverterTypeGmailError.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: BatchResponse, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .success(v1):
            writeInt(&buf, Int32(1))
            FfiConverterTypeGmailMessage.write(v1, into: &buf)
            
        
        case let .error(v1):
            writeInt(&buf, Int32(2))
            FfiConverterTypeGmailError.write(v1, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBatchResponse_lift(_ buf: RustBuffer) throws -> BatchResponse {
    return try FfiConverterTypeBatchResponse.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBatchResponse_lower(_ value: BatchResponse) -> RustBuffer {
    return FfiConverterTypeBatchResponse.lower(value)
}


extension BatchResponse: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum CalendarEventStatus {
    
    /**
     * Indicates event is tentative.
     */
    case tentative
    /**
     * Indicates event is definite.
     */
    case confirmed
    /**
     * Indicates event was cancelled.
     */
    case cancelled
}


#if compiler(>=6)
extension CalendarEventStatus: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeCalendarEventStatus: FfiConverterRustBuffer {
    typealias SwiftType = CalendarEventStatus

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CalendarEventStatus {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .tentative
        
        case 2: return .confirmed
        
        case 3: return .cancelled
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: CalendarEventStatus, into buf: inout [UInt8]) {
        switch value {
        
        
        case .tentative:
            writeInt(&buf, Int32(1))
        
        
        case .confirmed:
            writeInt(&buf, Int32(2))
        
        
        case .cancelled:
            writeInt(&buf, Int32(3))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCalendarEventStatus_lift(_ buf: RustBuffer) throws -> CalendarEventStatus {
    return try FfiConverterTypeCalendarEventStatus.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCalendarEventStatus_lower(_ value: CalendarEventStatus) -> RustBuffer {
    return FfiConverterTypeCalendarEventStatus.lower(value)
}


extension CalendarEventStatus: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum PaddingDirection {
    
    case left
    case right
}


#if compiler(>=6)
extension PaddingDirection: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePaddingDirection: FfiConverterRustBuffer {
    typealias SwiftType = PaddingDirection

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PaddingDirection {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .left
        
        case 2: return .right
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: PaddingDirection, into buf: inout [UInt8]) {
        switch value {
        
        
        case .left:
            writeInt(&buf, Int32(1))
        
        
        case .right:
            writeInt(&buf, Int32(2))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePaddingDirection_lift(_ buf: RustBuffer) throws -> PaddingDirection {
    return try FfiConverterTypePaddingDirection.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePaddingDirection_lower(_ value: PaddingDirection) -> RustBuffer {
    return FfiConverterTypePaddingDirection.lower(value)
}


extension PaddingDirection: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum PaddingStrategy {
    
    case batchLongest
    case fixed(UInt32
    )
}


#if compiler(>=6)
extension PaddingStrategy: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePaddingStrategy: FfiConverterRustBuffer {
    typealias SwiftType = PaddingStrategy

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PaddingStrategy {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .batchLongest
        
        case 2: return .fixed(try FfiConverterUInt32.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: PaddingStrategy, into buf: inout [UInt8]) {
        switch value {
        
        
        case .batchLongest:
            writeInt(&buf, Int32(1))
        
        
        case let .fixed(v1):
            writeInt(&buf, Int32(2))
            FfiConverterUInt32.write(v1, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePaddingStrategy_lift(_ buf: RustBuffer) throws -> PaddingStrategy {
    return try FfiConverterTypePaddingStrategy.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePaddingStrategy_lower(_ value: PaddingStrategy) -> RustBuffer {
    return FfiConverterTypePaddingStrategy.lower(value)
}


extension PaddingStrategy: Equatable, Hashable {}




public enum ParserError {

    
    
    case Base64DecodeFailed
    case NonUtfInput
    case EmptyInput
    case EmailParseFailed
    case NoFromHeader
    case NoToHeader
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeParserError: FfiConverterRustBuffer {
    typealias SwiftType = ParserError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ParserError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .Base64DecodeFailed
        case 2: return .NonUtfInput
        case 3: return .EmptyInput
        case 4: return .EmailParseFailed
        case 5: return .NoFromHeader
        case 6: return .NoToHeader

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ParserError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case .Base64DecodeFailed:
            writeInt(&buf, Int32(1))
        
        
        case .NonUtfInput:
            writeInt(&buf, Int32(2))
        
        
        case .EmptyInput:
            writeInt(&buf, Int32(3))
        
        
        case .EmailParseFailed:
            writeInt(&buf, Int32(4))
        
        
        case .NoFromHeader:
            writeInt(&buf, Int32(5))
        
        
        case .NoToHeader:
            writeInt(&buf, Int32(6))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeParserError_lift(_ buf: RustBuffer) throws -> ParserError {
    return try FfiConverterTypeParserError.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeParserError_lower(_ value: ParserError) -> RustBuffer {
    return FfiConverterTypeParserError.lower(value)
}


extension ParserError: Equatable, Hashable {}



extension ParserError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum SpecialTokens {
    
    case yes
    case no
}


#if compiler(>=6)
extension SpecialTokens: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSpecialTokens: FfiConverterRustBuffer {
    typealias SwiftType = SpecialTokens

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SpecialTokens {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .yes
        
        case 2: return .no
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: SpecialTokens, into buf: inout [UInt8]) {
        switch value {
        
        
        case .yes:
            writeInt(&buf, Int32(1))
        
        
        case .no:
            writeInt(&buf, Int32(2))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSpecialTokens_lift(_ buf: RustBuffer) throws -> SpecialTokens {
    return try FfiConverterTypeSpecialTokens.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSpecialTokens_lower(_ value: SpecialTokens) -> RustBuffer {
    return FfiConverterTypeSpecialTokens.lower(value)
}


extension SpecialTokens: Equatable, Hashable {}




public enum TokenizeError {

    
    
    case TokenizerCreationFailed
    case InputEncodingFailed
    case InvalidTruncationParams
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeTokenizeError: FfiConverterRustBuffer {
    typealias SwiftType = TokenizeError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TokenizeError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .TokenizerCreationFailed
        case 2: return .InputEncodingFailed
        case 3: return .InvalidTruncationParams

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: TokenizeError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case .TokenizerCreationFailed:
            writeInt(&buf, Int32(1))
        
        
        case .InputEncodingFailed:
            writeInt(&buf, Int32(2))
        
        
        case .InvalidTruncationParams:
            writeInt(&buf, Int32(3))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTokenizeError_lift(_ buf: RustBuffer) throws -> TokenizeError {
    return try FfiConverterTypeTokenizeError.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTokenizeError_lower(_ value: TokenizeError) -> RustBuffer {
    return FfiConverterTypeTokenizeError.lower(value)
}


extension TokenizeError: Equatable, Hashable {}



extension TokenizeError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum TruncationDirection {
    
    case left
    case right
}


#if compiler(>=6)
extension TruncationDirection: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeTruncationDirection: FfiConverterRustBuffer {
    typealias SwiftType = TruncationDirection

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TruncationDirection {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .left
        
        case 2: return .right
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: TruncationDirection, into buf: inout [UInt8]) {
        switch value {
        
        
        case .left:
            writeInt(&buf, Int32(1))
        
        
        case .right:
            writeInt(&buf, Int32(2))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTruncationDirection_lift(_ buf: RustBuffer) throws -> TruncationDirection {
    return try FfiConverterTypeTruncationDirection.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTruncationDirection_lower(_ value: TruncationDirection) -> RustBuffer {
    return FfiConverterTypeTruncationDirection.lower(value)
}


extension TruncationDirection: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum TruncationStrategy {
    
    case longestFirst
    case onlyFirst
    case onlySecond
}


#if compiler(>=6)
extension TruncationStrategy: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeTruncationStrategy: FfiConverterRustBuffer {
    typealias SwiftType = TruncationStrategy

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TruncationStrategy {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .longestFirst
        
        case 2: return .onlyFirst
        
        case 3: return .onlySecond
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: TruncationStrategy, into buf: inout [UInt8]) {
        switch value {
        
        
        case .longestFirst:
            writeInt(&buf, Int32(1))
        
        
        case .onlyFirst:
            writeInt(&buf, Int32(2))
        
        
        case .onlySecond:
            writeInt(&buf, Int32(3))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTruncationStrategy_lift(_ buf: RustBuffer) throws -> TruncationStrategy {
    return try FfiConverterTypeTruncationStrategy.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTruncationStrategy_lower(_ value: TruncationStrategy) -> RustBuffer {
    return FfiConverterTypeTruncationStrategy.lower(value)
}


extension TruncationStrategy: Equatable, Hashable {}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionUInt32: FfiConverterRustBuffer {
    typealias SwiftType = UInt32?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterUInt32.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterUInt32.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionInt64: FfiConverterRustBuffer {
    typealias SwiftType = Int64?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterInt64.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterInt64.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionString: FfiConverterRustBuffer {
    typealias SwiftType = String?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterString.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterString.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypePaddingParams: FfiConverterRustBuffer {
    typealias SwiftType = PaddingParams?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypePaddingParams.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypePaddingParams.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeReturnToken: FfiConverterRustBuffer {
    typealias SwiftType = ReturnToken?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeReturnToken.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeReturnToken.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeTruncationParams: FfiConverterRustBuffer {
    typealias SwiftType = TruncationParams?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeTruncationParams.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeTruncationParams.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeUnsubscribeEmail: FfiConverterRustBuffer {
    typealias SwiftType = UnsubscribeEmail?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeUnsubscribeEmail.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeUnsubscribeEmail.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeUnsubscribePost: FfiConverterRustBuffer {
    typealias SwiftType = UnsubscribePost?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeUnsubscribePost.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeUnsubscribePost.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeCalendarEventStatus: FfiConverterRustBuffer {
    typealias SwiftType = CalendarEventStatus?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeCalendarEventStatus.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeCalendarEventStatus.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceUInt32: FfiConverterRustBuffer {
    typealias SwiftType = [UInt32]

    public static func write(_ value: [UInt32], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterUInt32.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [UInt32] {
        let len: Int32 = try readInt(&buf)
        var seq = [UInt32]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterUInt32.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceString: FfiConverterRustBuffer {
    typealias SwiftType = [String]

    public static func write(_ value: [String], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterString.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String] {
        let len: Int32 = try readInt(&buf)
        var seq = [String]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterString.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeBatchSection: FfiConverterRustBuffer {
    typealias SwiftType = [BatchSection]

    public static func write(_ value: [BatchSection], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeBatchSection.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [BatchSection] {
        let len: Int32 = try readInt(&buf)
        var seq = [BatchSection]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeBatchSection.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeCalendarEvent: FfiConverterRustBuffer {
    typealias SwiftType = [CalendarEvent]

    public static func write(_ value: [CalendarEvent], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeCalendarEvent.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [CalendarEvent] {
        let len: Int32 = try readInt(&buf)
        var seq = [CalendarEvent]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeCalendarEvent.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeEmailAddress: FfiConverterRustBuffer {
    typealias SwiftType = [EmailAddress]

    public static func write(_ value: [EmailAddress], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeEmailAddress.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [EmailAddress] {
        let len: Int32 = try readInt(&buf)
        var seq = [EmailAddress]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeEmailAddress.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeEmailText: FfiConverterRustBuffer {
    typealias SwiftType = [EmailText]

    public static func write(_ value: [EmailText], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeEmailText.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [EmailText] {
        let len: Int32 = try readInt(&buf)
        var seq = [EmailText]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeEmailText.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeGmailErrorItem: FfiConverterRustBuffer {
    typealias SwiftType = [GmailErrorItem]

    public static func write(_ value: [GmailErrorItem], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeGmailErrorItem.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [GmailErrorItem] {
        let len: Int32 = try readInt(&buf)
        var seq = [GmailErrorItem]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeGmailErrorItem.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeHeader: FfiConverterRustBuffer {
    typealias SwiftType = [Header]

    public static func write(_ value: [Header], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeHeader.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Header] {
        let len: Int32 = try readInt(&buf)
        var seq = [Header]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeHeader.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeMicrodataItem: FfiConverterRustBuffer {
    typealias SwiftType = [MicrodataItem]

    public static func write(_ value: [MicrodataItem], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeMicrodataItem.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [MicrodataItem] {
        let len: Int32 = try readInt(&buf)
        var seq = [MicrodataItem]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeMicrodataItem.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeToken: FfiConverterRustBuffer {
    typealias SwiftType = [Token]

    public static func write(_ value: [Token], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeToken.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Token] {
        let len: Int32 = try readInt(&buf)
        var seq = [Token]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeToken.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceSequenceUInt32: FfiConverterRustBuffer {
    typealias SwiftType = [[UInt32]]

    public static func write(_ value: [[UInt32]], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterSequenceUInt32.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [[UInt32]] {
        let len: Int32 = try readInt(&buf)
        var seq = [[UInt32]]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterSequenceUInt32.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterDictionaryStringString: FfiConverterRustBuffer {
    public static func write(_ value: [String: String], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterString.write(key, into: &buf)
            FfiConverterString.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String: String] {
        let len: Int32 = try readInt(&buf)
        var dict = [String: String]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterString.read(from: &buf)
            let value = try FfiConverterString.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterDictionaryStringTypeMicrodataItem: FfiConverterRustBuffer {
    public static func write(_ value: [String: MicrodataItem], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterString.write(key, into: &buf)
            FfiConverterTypeMicrodataItem.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String: MicrodataItem] {
        let len: Int32 = try readInt(&buf)
        var dict = [String: MicrodataItem]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterString.read(from: &buf)
            let value = try FfiConverterTypeMicrodataItem.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}
public func escapeText(text: String) -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_vella_sdk_fn_func_escape_text(
        FfiConverterString.lower(text),$0
    )
})
}
public func parseBatchResponse(body: String) -> [BatchSection]  {
    return try!  FfiConverterSequenceTypeBatchSection.lift(try! rustCall() {
    uniffi_vella_sdk_fn_func_parse_batch_response(
        FfiConverterString.lower(body),$0
    )
})
}
public func parseEmail(raw: String)throws  -> Email  {
    return try  FfiConverterTypeEmail_lift(try rustCallWithError(FfiConverterTypeParserError_lift) {
    uniffi_vella_sdk_fn_func_parse_email(
        FfiConverterString.lower(raw),$0
    )
})
}
public func parseVisibleHtml(body: String) -> String?  {
    return try!  FfiConverterOptionString.lift(try! rustCall() {
    uniffi_vella_sdk_fn_func_parse_visible_html(
        FfiConverterString.lower(body),$0
    )
})
}
public func parseVisibleText(body: String) -> String?  {
    return try!  FfiConverterOptionString.lift(try! rustCall() {
    uniffi_vella_sdk_fn_func_parse_visible_text(
        FfiConverterString.lower(body),$0
    )
})
}

private enum InitializationResult {
    case ok
    case contractVersionMismatch
    case apiChecksumMismatch
}
// Use a global variable to perform the versioning checks. Swift ensures that
// the code inside is only computed once.
private let initializationResult: InitializationResult = {
    // Get the bindings contract version from our ComponentInterface
    let bindings_contract_version = 29
    // Get the scaffolding contract version by calling the into the dylib
    let scaffolding_contract_version = ffi_vella_sdk_uniffi_contract_version()
    if bindings_contract_version != scaffolding_contract_version {
        return InitializationResult.contractVersionMismatch
    }
    if (uniffi_vella_sdk_checksum_func_escape_text() != 30725) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_vella_sdk_checksum_func_parse_batch_response() != 14624) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_vella_sdk_checksum_func_parse_email() != 23062) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_vella_sdk_checksum_func_parse_visible_html() != 14978) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_vella_sdk_checksum_func_parse_visible_text() != 17560) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_vella_sdk_checksum_method_customtokenizerinner_decode() != 41492) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_vella_sdk_checksum_method_customtokenizerinner_get_ids() != 28986) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_vella_sdk_checksum_method_customtokenizerinner_get_pad_token() != 39869) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_vella_sdk_checksum_method_customtokenizerinner_get_tokens() != 27258) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_vella_sdk_checksum_method_customtokenizerinner_id_to_token() != 31500) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_vella_sdk_checksum_method_customtokenizerinner_token_to_id() != 55982) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_vella_sdk_checksum_method_customtokenizerinner_tokenize() != 39025) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_vella_sdk_checksum_method_customtokenizerinner_tokenize_batch() != 50675) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_vella_sdk_checksum_constructor_customtokenizerinner_new() != 38265) {
        return InitializationResult.apiChecksumMismatch
    }

    return InitializationResult.ok
}()

// Make the ensure init function public so that other modules which have external type references to
// our types can call it.
public func uniffiEnsureVellaSdkInitialized() {
    switch initializationResult {
    case .ok:
        break
    case .contractVersionMismatch:
        fatalError("UniFFI contract version mismatch: try cleaning and rebuilding your project")
    case .apiChecksumMismatch:
        fatalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
}

// swiftlint:enable all